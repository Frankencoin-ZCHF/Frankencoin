{
  "language": "Solidity",
  "sources": {
    "@chainlink/contracts-ccip/src/v0.8/ccip/applications/CCIPReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport {IAny2EVMMessageReceiver} from \"../interfaces/IAny2EVMMessageReceiver.sol\";\n\nimport {Client} from \"../libraries/Client.sol\";\n\nimport {IERC165} from \"../../vendor/openzeppelin-solidity/v5.0.2/contracts/utils/introspection/IERC165.sol\";\n\n/// @title CCIPReceiver - Base contract for CCIP applications that can receive messages.\nabstract contract CCIPReceiver is IAny2EVMMessageReceiver, IERC165 {\n  address internal immutable i_ccipRouter;\n\n  constructor(\n    address router\n  ) {\n    if (router == address(0)) revert InvalidRouter(address(0));\n    i_ccipRouter = router;\n  }\n\n  /// @notice IERC165 supports an interfaceId\n  /// @param interfaceId The interfaceId to check\n  /// @return true if the interfaceId is supported\n  /// @dev Should indicate whether the contract implements IAny2EVMMessageReceiver\n  /// e.g. return interfaceId == type(IAny2EVMMessageReceiver).interfaceId || interfaceId == type(IERC165).interfaceId\n  /// This allows CCIP to check if ccipReceive is available before calling it.\n  /// If this returns false or reverts, only tokens are transferred to the receiver.\n  /// If this returns true, tokens are transferred and ccipReceive is called atomically.\n  /// Additionally, if the receiver address does not have code associated with\n  /// it at the time of execution (EXTCODESIZE returns 0), only tokens will be transferred.\n  function supportsInterface(\n    bytes4 interfaceId\n  ) public view virtual override returns (bool) {\n    return interfaceId == type(IAny2EVMMessageReceiver).interfaceId || interfaceId == type(IERC165).interfaceId;\n  }\n\n  /// @inheritdoc IAny2EVMMessageReceiver\n  function ccipReceive(\n    Client.Any2EVMMessage calldata message\n  ) external virtual override onlyRouter {\n    _ccipReceive(message);\n  }\n\n  /// @notice Override this function in your implementation.\n  /// @param message Any2EVMMessage\n  function _ccipReceive(\n    Client.Any2EVMMessage memory message\n  ) internal virtual;\n\n  /////////////////////////////////////////////////////////////////////\n  // Plumbing\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Return the current router\n  /// @return CCIP router address\n  function getRouter() public view virtual returns (address) {\n    return address(i_ccipRouter);\n  }\n\n  error InvalidRouter(address router);\n\n  /// @dev only calls from the set router are accepted.\n  modifier onlyRouter() {\n    if (msg.sender != getRouter()) revert InvalidRouter(msg.sender);\n    _;\n  }\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IAny2EVMMessageReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Client} from \"../libraries/Client.sol\";\n\n/// @notice Application contracts that intend to receive messages from\n/// the router should implement this interface.\ninterface IAny2EVMMessageReceiver {\n  /// @notice Called by the Router to deliver a message.\n  /// If this reverts, any token transfers also revert. The message\n  /// will move to a FAILED state and become available for manual execution.\n  /// @param message CCIP Message\n  /// @dev Note ensure you check the msg.sender is the OffRampRouter\n  function ccipReceive(\n    Client.Any2EVMMessage calldata message\n  ) external;\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IGetCCIPAdmin.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IGetCCIPAdmin {\n  /// @notice Returns the admin of the token.\n  /// @dev This method is named to never conflict with existing methods.\n  function getCCIPAdmin() external view returns (address);\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IOwner.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IOwner {\n  /// @notice Returns the owner of the contract.\n  /// @dev This method is named to match with the OpenZeppelin Ownable contract.\n  function owner() external view returns (address);\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Pool} from \"../libraries/Pool.sol\";\n\nimport {IERC165} from \"../../vendor/openzeppelin-solidity/v5.0.2/contracts/utils/introspection/IERC165.sol\";\n\n/// @notice Shared public interface for multiple V1 pool types.\n/// Each pool type handles a different child token model (lock/unlock, mint/burn.)\ninterface IPoolV1 is IERC165 {\n  /// @notice Lock tokens into the pool or burn the tokens.\n  /// @param lockOrBurnIn Encoded data fields for the processing of tokens on the source chain.\n  /// @return lockOrBurnOut Encoded data fields for the processing of tokens on the destination chain.\n  function lockOrBurn(\n    Pool.LockOrBurnInV1 calldata lockOrBurnIn\n  ) external returns (Pool.LockOrBurnOutV1 memory lockOrBurnOut);\n\n  /// @notice Releases or mints tokens to the receiver address.\n  /// @param releaseOrMintIn All data required to release or mint tokens.\n  /// @return releaseOrMintOut The amount of tokens released or minted on the local chain, denominated\n  /// in the local token's decimals.\n  /// @dev The offramp asserts that the balanceOf of the receiver has been incremented by exactly the number\n  /// of tokens that is returned in ReleaseOrMintOutV1.destinationAmount. If the amounts do not match, the tx reverts.\n  function releaseOrMint(\n    Pool.ReleaseOrMintInV1 calldata releaseOrMintIn\n  ) external returns (Pool.ReleaseOrMintOutV1 memory);\n\n  /// @notice Checks whether a remote chain is supported in the token pool.\n  /// @param remoteChainSelector The selector of the remote chain.\n  /// @return true if the given chain is a permissioned remote chain.\n  function isSupportedChain(\n    uint64 remoteChainSelector\n  ) external view returns (bool);\n\n  /// @notice Returns if the token pool supports the given token.\n  /// @param token The address of the token.\n  /// @return true if the token is supported by the pool.\n  function isSupportedToken(\n    address token\n  ) external view returns (bool);\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IRMN.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @notice This interface contains the only RMN-related functions that might be used on-chain by other CCIP contracts.\ninterface IRMN {\n  /// @notice A Merkle root tagged with the address of the commit store contract it is destined for.\n  struct TaggedRoot {\n    address commitStore;\n    bytes32 root;\n  }\n\n  /// @notice Callers MUST NOT cache the return value as a blessed tagged root could become unblessed.\n  function isBlessed(\n    TaggedRoot calldata taggedRoot\n  ) external view returns (bool);\n\n  /// @notice Iff there is an active global or legacy curse, this function returns true.\n  function isCursed() external view returns (bool);\n\n  /// @notice Iff there is an active global curse, or an active curse for `subject`, this function returns true.\n  /// @param subject To check whether a particular chain is cursed, set to bytes16(uint128(chainSelector)).\n  function isCursed(\n    bytes16 subject\n  ) external view returns (bool);\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Client} from \"../libraries/Client.sol\";\n\ninterface IRouter {\n  error OnlyOffRamp();\n\n  /// @notice Route the message to its intended receiver contract.\n  /// @param message Client.Any2EVMMessage struct.\n  /// @param gasForCallExactCheck of params for exec\n  /// @param gasLimit set of params for exec\n  /// @param receiver set of params for exec\n  /// @dev if the receiver is a contracts that signals support for CCIP execution through EIP-165.\n  /// the contract is called. If not, only tokens are transferred.\n  /// @return success A boolean value indicating whether the ccip message was received without errors.\n  /// @return retBytes A bytes array containing return data form CCIP receiver.\n  /// @return gasUsed the gas used by the external customer call. Does not include any overhead.\n  function routeMessage(\n    Client.Any2EVMMessage calldata message,\n    uint16 gasForCallExactCheck,\n    uint256 gasLimit,\n    address receiver\n  ) external returns (bool success, bytes memory retBytes, uint256 gasUsed);\n\n  /// @notice Returns the configured onramp for a specific destination chain.\n  /// @param destChainSelector The destination chain Id to get the onRamp for.\n  /// @return onRampAddress The address of the onRamp.\n  function getOnRamp(\n    uint64 destChainSelector\n  ) external view returns (address onRampAddress);\n\n  /// @notice Return true if the given offRamp is a configured offRamp for the given source chain.\n  /// @param sourceChainSelector The source chain selector to check.\n  /// @param offRamp The address of the offRamp to check.\n  function isOffRamp(uint64 sourceChainSelector, address offRamp) external view returns (bool isOffRamp);\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IRouterClient.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport {Client} from \"../libraries/Client.sol\";\n\ninterface IRouterClient {\n  error UnsupportedDestinationChain(uint64 destChainSelector);\n  error InsufficientFeeTokenAmount();\n  error InvalidMsgValue();\n\n  /// @notice Checks if the given chain ID is supported for sending/receiving.\n  /// @param destChainSelector The chain to check.\n  /// @return supported is true if it is supported, false if not.\n  function isChainSupported(\n    uint64 destChainSelector\n  ) external view returns (bool supported);\n\n  /// @param destinationChainSelector The destination chainSelector\n  /// @param message The cross-chain CCIP message including data and/or tokens\n  /// @return fee returns execution fee for the message\n  /// delivery to destination chain, denominated in the feeToken specified in the message.\n  /// @dev Reverts with appropriate reason upon invalid message.\n  function getFee(\n    uint64 destinationChainSelector,\n    Client.EVM2AnyMessage memory message\n  ) external view returns (uint256 fee);\n\n  /// @notice Request a message to be sent to the destination chain\n  /// @param destinationChainSelector The destination chain ID\n  /// @param message The cross-chain CCIP message including data and/or tokens\n  /// @return messageId The message ID\n  /// @dev Note if msg.value is larger than the required fee (from getFee) we accept\n  /// the overpayment with no refund.\n  /// @dev Reverts with appropriate reason upon invalid message.\n  function ccipSend(\n    uint64 destinationChainSelector,\n    Client.EVM2AnyMessage calldata message\n  ) external payable returns (bytes32);\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/ITokenAdminRegistry.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\ninterface ITokenAdminRegistry {\n  /// @notice Returns the pool for the given token.\n  function getPool(\n    address token\n  ) external view returns (address);\n\n  /// @notice Proposes an administrator for the given token as pending administrator.\n  /// @param localToken The token to register the administrator for.\n  /// @param administrator The administrator to register.\n  function proposeAdministrator(address localToken, address administrator) external;\n\n  /// @notice Accepts the administrator role for a token.\n  /// @param localToken The token to accept the administrator role for.\n  /// @dev This function can only be called by the pending administrator.\n  function acceptAdminRole(\n    address localToken\n  ) external;\n\n  /// @notice Sets the pool for a token. Setting the pool to address(0) effectively delists the token\n  /// from CCIP. Setting the pool to any other address enables the token on CCIP.\n  /// @param localToken The token to set the pool for.\n  /// @param pool The pool to set for the token.\n  function setPool(address localToken, address pool) external;\n\n  /// @notice Transfers the administrator role for a token to a new address with a 2-step process.\n  /// @param localToken The token to transfer the administrator role for.\n  /// @param newAdmin The address to transfer the administrator role to. Can be address(0) to cancel\n  /// a pending transfer.\n  /// @dev The new admin must call `acceptAdminRole` to accept the role.\n  function transferAdminRole(address localToken, address newAdmin) external;\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/ccip/libraries/Client.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// End consumer library.\nlibrary Client {\n  /// @dev RMN depends on this struct, if changing, please notify the RMN maintainers.\n  struct EVMTokenAmount {\n    address token; // token address on the local chain.\n    uint256 amount; // Amount of tokens.\n  }\n\n  struct Any2EVMMessage {\n    bytes32 messageId; // MessageId corresponding to ccipSend on source.\n    uint64 sourceChainSelector; // Source chain selector.\n    bytes sender; // abi.decode(sender) if coming from an EVM chain.\n    bytes data; // payload sent in original message.\n    EVMTokenAmount[] destTokenAmounts; // Tokens and their amounts in their destination chain representation.\n  }\n\n  // If extraArgs is empty bytes, the default is 200k gas limit.\n  struct EVM2AnyMessage {\n    bytes receiver; // abi.encode(receiver address) for dest EVM chains\n    bytes data; // Data payload\n    EVMTokenAmount[] tokenAmounts; // Token transfers\n    address feeToken; // Address of feeToken. address(0) means you will send msg.value.\n    bytes extraArgs; // Populate this with _argsToBytes(EVMExtraArgsV2)\n  }\n\n  // bytes4(keccak256(\"CCIP EVMExtraArgsV1\"));\n  bytes4 public constant EVM_EXTRA_ARGS_V1_TAG = 0x97a657c9;\n\n  struct EVMExtraArgsV1 {\n    uint256 gasLimit;\n  }\n\n  function _argsToBytes(\n    EVMExtraArgsV1 memory extraArgs\n  ) internal pure returns (bytes memory bts) {\n    return abi.encodeWithSelector(EVM_EXTRA_ARGS_V1_TAG, extraArgs);\n  }\n\n  // bytes4(keccak256(\"CCIP EVMExtraArgsV2\"));\n  bytes4 public constant EVM_EXTRA_ARGS_V2_TAG = 0x181dcf10;\n\n  /// @param gasLimit: gas limit for the callback on the destination chain.\n  /// @param allowOutOfOrderExecution: if true, it indicates that the message can be executed in any order relative to other messages from the same sender.\n  /// This value's default varies by chain. On some chains, a particular value is enforced, meaning if the expected value\n  /// is not set, the message request will revert.\n  struct EVMExtraArgsV2 {\n    uint256 gasLimit;\n    bool allowOutOfOrderExecution;\n  }\n\n  function _argsToBytes(\n    EVMExtraArgsV2 memory extraArgs\n  ) internal pure returns (bytes memory bts) {\n    return abi.encodeWithSelector(EVM_EXTRA_ARGS_V2_TAG, extraArgs);\n  }\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/ccip/libraries/Pool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @notice This library contains various token pool functions to aid constructing the return data.\nlibrary Pool {\n  // The tag used to signal support for the pool v1 standard\n  // bytes4(keccak256(\"CCIP_POOL_V1\"))\n  bytes4 public constant CCIP_POOL_V1 = 0xaff2afbf;\n\n  // The number of bytes in the return data for a pool v1 releaseOrMint call.\n  // This should match the size of the ReleaseOrMintOutV1 struct.\n  uint16 public constant CCIP_POOL_V1_RET_BYTES = 32;\n\n  // The default max number of bytes in the return data for a pool v1 lockOrBurn call.\n  // This data can be used to send information to the destination chain token pool. Can be overwritten\n  // in the TokenTransferFeeConfig.destBytesOverhead if more data is required.\n  uint32 public constant CCIP_LOCK_OR_BURN_V1_RET_BYTES = 32;\n\n  struct LockOrBurnInV1 {\n    bytes receiver; //  The recipient of the tokens on the destination chain, abi encoded\n    uint64 remoteChainSelector; // ─╮ The chain ID of the destination chain\n    address originalSender; // ─────╯ The original sender of the tx on the source chain\n    uint256 amount; //  The amount of tokens to lock or burn, denominated in the source token's decimals\n    address localToken; //  The address on this chain of the token to lock or burn\n  }\n\n  struct LockOrBurnOutV1 {\n    // The address of the destination token, abi encoded in the case of EVM chains\n    // This value is UNTRUSTED as any pool owner can return whatever value they want.\n    bytes destTokenAddress;\n    // Optional pool data to be transferred to the destination chain. Be default this is capped at\n    // CCIP_LOCK_OR_BURN_V1_RET_BYTES bytes. If more data is required, the TokenTransferFeeConfig.destBytesOverhead\n    // has to be set for the specific token.\n    bytes destPoolData;\n  }\n\n  struct ReleaseOrMintInV1 {\n    bytes originalSender; //          The original sender of the tx on the source chain\n    uint64 remoteChainSelector; // ─╮ The chain ID of the source chain\n    address receiver; // ───────────╯ The recipient of the tokens on the destination chain.\n    uint256 amount; //                The amount of tokens to release or mint, denominated in the source token's decimals\n    address localToken; //            The address on this chain of the token to release or mint\n    /// @dev WARNING: sourcePoolAddress should be checked prior to any processing of funds. Make sure it matches the\n    /// expected pool address for the given remoteChainSelector.\n    bytes sourcePoolAddress; //       The address of the source pool, abi encoded in the case of EVM chains\n    bytes sourcePoolData; //          The data received from the source pool to process the release or mint\n    /// @dev WARNING: offchainTokenData is untrusted data.\n    bytes offchainTokenData; //       The offchain data to process the release or mint\n  }\n\n  struct ReleaseOrMintOutV1 {\n    // The number of tokens released or minted on the destination chain, denominated in the local token's decimals.\n    // This value is expected to be equal to the ReleaseOrMintInV1.amount in the case where the source and destination\n    // chain have the same number of decimals.\n    uint256 destinationAmount;\n  }\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/ccip/libraries/RateLimiter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.4;\n\n/// @notice Implements Token Bucket rate limiting.\n/// @dev uint128 is safe for rate limiter state.\n/// For USD value rate limiting, it can adequately store USD value in 18 decimals.\n/// For ERC20 token amount rate limiting, all tokens that will be listed will have at most\n/// a supply of uint128.max tokens, and it will therefore not overflow the bucket.\n/// In exceptional scenarios where tokens consumed may be larger than uint128,\n/// e.g. compromised issuer, an enabled RateLimiter will check and revert.\nlibrary RateLimiter {\n  error BucketOverfilled();\n  error OnlyCallableByAdminOrOwner();\n  error TokenMaxCapacityExceeded(uint256 capacity, uint256 requested, address tokenAddress);\n  error TokenRateLimitReached(uint256 minWaitInSeconds, uint256 available, address tokenAddress);\n  error AggregateValueMaxCapacityExceeded(uint256 capacity, uint256 requested);\n  error AggregateValueRateLimitReached(uint256 minWaitInSeconds, uint256 available);\n  error InvalidRateLimitRate(Config rateLimiterConfig);\n  error DisabledNonZeroRateLimit(Config config);\n  error RateLimitMustBeDisabled();\n\n  event TokensConsumed(uint256 tokens);\n  event ConfigChanged(Config config);\n\n  struct TokenBucket {\n    uint128 tokens; // ──────╮ Current number of tokens that are in the bucket.\n    uint32 lastUpdated; //   │ Timestamp in seconds of the last token refill, good for 100+ years.\n    bool isEnabled; // ──────╯ Indication whether the rate limiting is enabled or not\n    uint128 capacity; // ────╮ Maximum number of tokens that can be in the bucket.\n    uint128 rate; // ────────╯ Number of tokens per second that the bucket is refilled.\n  }\n\n  struct Config {\n    bool isEnabled; // Indication whether the rate limiting should be enabled\n    uint128 capacity; // ────╮ Specifies the capacity of the rate limiter\n    uint128 rate; //  ───────╯ Specifies the rate of the rate limiter\n  }\n\n  /// @notice _consume removes the given tokens from the pool, lowering the\n  /// rate tokens allowed to be consumed for subsequent calls.\n  /// @param requestTokens The total tokens to be consumed from the bucket.\n  /// @param tokenAddress The token to consume capacity for, use 0x0 to indicate aggregate value capacity.\n  /// @dev Reverts when requestTokens exceeds bucket capacity or available tokens in the bucket\n  /// @dev emits removal of requestTokens if requestTokens is > 0\n  function _consume(TokenBucket storage s_bucket, uint256 requestTokens, address tokenAddress) internal {\n    // If there is no value to remove or rate limiting is turned off, skip this step to reduce gas usage\n    if (!s_bucket.isEnabled || requestTokens == 0) {\n      return;\n    }\n\n    uint256 tokens = s_bucket.tokens;\n    uint256 capacity = s_bucket.capacity;\n    uint256 timeDiff = block.timestamp - s_bucket.lastUpdated;\n\n    if (timeDiff != 0) {\n      if (tokens > capacity) revert BucketOverfilled();\n\n      // Refill tokens when arriving at a new block time\n      tokens = _calculateRefill(capacity, tokens, timeDiff, s_bucket.rate);\n\n      s_bucket.lastUpdated = uint32(block.timestamp);\n    }\n\n    if (capacity < requestTokens) {\n      // Token address 0 indicates consuming aggregate value rate limit capacity.\n      if (tokenAddress == address(0)) revert AggregateValueMaxCapacityExceeded(capacity, requestTokens);\n      revert TokenMaxCapacityExceeded(capacity, requestTokens, tokenAddress);\n    }\n    if (tokens < requestTokens) {\n      uint256 rate = s_bucket.rate;\n      // Wait required until the bucket is refilled enough to accept this value, round up to next higher second\n      // Consume is not guaranteed to succeed after wait time passes if there is competing traffic.\n      // This acts as a lower bound of wait time.\n      uint256 minWaitInSeconds = ((requestTokens - tokens) + (rate - 1)) / rate;\n\n      if (tokenAddress == address(0)) revert AggregateValueRateLimitReached(minWaitInSeconds, tokens);\n      revert TokenRateLimitReached(minWaitInSeconds, tokens, tokenAddress);\n    }\n    tokens -= requestTokens;\n\n    // Downcast is safe here, as tokens is not larger than capacity\n    s_bucket.tokens = uint128(tokens);\n    emit TokensConsumed(requestTokens);\n  }\n\n  /// @notice Gets the token bucket with its values for the block it was requested at.\n  /// @return The token bucket.\n  function _currentTokenBucketState(\n    TokenBucket memory bucket\n  ) internal view returns (TokenBucket memory) {\n    // We update the bucket to reflect the status at the exact time of the\n    // call. This means we might need to refill a part of the bucket based\n    // on the time that has passed since the last update.\n    bucket.tokens =\n      uint128(_calculateRefill(bucket.capacity, bucket.tokens, block.timestamp - bucket.lastUpdated, bucket.rate));\n    bucket.lastUpdated = uint32(block.timestamp);\n    return bucket;\n  }\n\n  /// @notice Sets the rate limited config.\n  /// @param s_bucket The token bucket\n  /// @param config The new config\n  function _setTokenBucketConfig(TokenBucket storage s_bucket, Config memory config) internal {\n    // First update the bucket to make sure the proper rate is used for all the time\n    // up until the config change.\n    uint256 timeDiff = block.timestamp - s_bucket.lastUpdated;\n    if (timeDiff != 0) {\n      s_bucket.tokens = uint128(_calculateRefill(s_bucket.capacity, s_bucket.tokens, timeDiff, s_bucket.rate));\n\n      s_bucket.lastUpdated = uint32(block.timestamp);\n    }\n\n    s_bucket.tokens = uint128(_min(config.capacity, s_bucket.tokens));\n    s_bucket.isEnabled = config.isEnabled;\n    s_bucket.capacity = config.capacity;\n    s_bucket.rate = config.rate;\n\n    emit ConfigChanged(config);\n  }\n\n  /// @notice Validates the token bucket config\n  function _validateTokenBucketConfig(Config memory config, bool mustBeDisabled) internal pure {\n    if (config.isEnabled) {\n      if (config.rate >= config.capacity || config.rate == 0) {\n        revert InvalidRateLimitRate(config);\n      }\n      if (mustBeDisabled) {\n        revert RateLimitMustBeDisabled();\n      }\n    } else {\n      if (config.rate != 0 || config.capacity != 0) {\n        revert DisabledNonZeroRateLimit(config);\n      }\n    }\n  }\n\n  /// @notice Calculate refilled tokens\n  /// @param capacity bucket capacity\n  /// @param tokens current bucket tokens\n  /// @param timeDiff block time difference since last refill\n  /// @param rate bucket refill rate\n  /// @return the value of tokens after refill\n  function _calculateRefill(\n    uint256 capacity,\n    uint256 tokens,\n    uint256 timeDiff,\n    uint256 rate\n  ) private pure returns (uint256) {\n    return _min(capacity, tokens + timeDiff * rate);\n  }\n\n  /// @notice Return the smallest of two integers\n  /// @param a first int\n  /// @param b second int\n  /// @return smallest\n  function _min(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a < b ? a : b;\n  }\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/ccip/pools/BurnMintTokenPool.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.24;\n\nimport {ITypeAndVersion} from \"../../shared/interfaces/ITypeAndVersion.sol\";\nimport {IBurnMintERC20} from \"../../shared/token/ERC20/IBurnMintERC20.sol\";\n\nimport {BurnMintTokenPoolAbstract} from \"./BurnMintTokenPoolAbstract.sol\";\nimport {TokenPool} from \"./TokenPool.sol\";\n\n/// @notice This pool mints and burns a 3rd-party token.\n/// @dev Pool whitelisting mode is set in the constructor and cannot be modified later.\n/// It either accepts any address as originalSender, or only accepts whitelisted originalSender.\n/// The only way to change whitelisting mode is to deploy a new pool.\n/// If that is expected, please make sure the token's burner/minter roles are adjustable.\n/// @dev This contract is a variant of BurnMintTokenPool that uses `burn(amount)`.\ncontract BurnMintTokenPool is BurnMintTokenPoolAbstract, ITypeAndVersion {\n  string public constant override typeAndVersion = \"BurnMintTokenPool 1.5.1\";\n\n  constructor(\n    IBurnMintERC20 token,\n    uint8 localTokenDecimals,\n    address[] memory allowlist,\n    address rmnProxy,\n    address router\n  ) TokenPool(token, localTokenDecimals, allowlist, rmnProxy, router) {}\n\n  /// @inheritdoc BurnMintTokenPoolAbstract\n  function _burn(\n    uint256 amount\n  ) internal virtual override {\n    IBurnMintERC20(address(i_token)).burn(amount);\n  }\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/ccip/pools/BurnMintTokenPoolAbstract.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.24;\n\nimport {IBurnMintERC20} from \"../../shared/token/ERC20/IBurnMintERC20.sol\";\n\nimport {Pool} from \"../libraries/Pool.sol\";\nimport {TokenPool} from \"./TokenPool.sol\";\n\nabstract contract BurnMintTokenPoolAbstract is TokenPool {\n  /// @notice Contains the specific burn call for a pool.\n  /// @dev overriding this method allows us to create pools with different burn signatures\n  /// without duplicating the underlying logic.\n  function _burn(\n    uint256 amount\n  ) internal virtual;\n\n  /// @notice Burn the token in the pool\n  /// @dev The _validateLockOrBurn check is an essential security check\n  function lockOrBurn(\n    Pool.LockOrBurnInV1 calldata lockOrBurnIn\n  ) external virtual override returns (Pool.LockOrBurnOutV1 memory) {\n    _validateLockOrBurn(lockOrBurnIn);\n\n    _burn(lockOrBurnIn.amount);\n\n    emit Burned(msg.sender, lockOrBurnIn.amount);\n\n    return Pool.LockOrBurnOutV1({\n      destTokenAddress: getRemoteToken(lockOrBurnIn.remoteChainSelector),\n      destPoolData: _encodeLocalDecimals()\n    });\n  }\n\n  /// @notice Mint tokens from the pool to the recipient\n  /// @dev The _validateReleaseOrMint check is an essential security check\n  function releaseOrMint(\n    Pool.ReleaseOrMintInV1 calldata releaseOrMintIn\n  ) external virtual override returns (Pool.ReleaseOrMintOutV1 memory) {\n    _validateReleaseOrMint(releaseOrMintIn);\n\n    // Calculate the local amount\n    uint256 localAmount =\n      _calculateLocalAmount(releaseOrMintIn.amount, _parseRemoteDecimals(releaseOrMintIn.sourcePoolData));\n\n    // Mint to the receiver\n    IBurnMintERC20(address(i_token)).mint(releaseOrMintIn.receiver, localAmount);\n\n    emit Minted(msg.sender, releaseOrMintIn.receiver, localAmount);\n\n    return Pool.ReleaseOrMintOutV1({destinationAmount: localAmount});\n  }\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/ccip/pools/TokenPool.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.24;\n\nimport {IPoolV1} from \"../interfaces/IPool.sol\";\nimport {IRMN} from \"../interfaces/IRMN.sol\";\nimport {IRouter} from \"../interfaces/IRouter.sol\";\n\nimport {Ownable2StepMsgSender} from \"../../shared/access/Ownable2StepMsgSender.sol\";\nimport {Pool} from \"../libraries/Pool.sol\";\nimport {RateLimiter} from \"../libraries/RateLimiter.sol\";\n\nimport {IERC20} from \"../../vendor/openzeppelin-solidity/v4.8.3/contracts/token/ERC20/IERC20.sol\";\nimport {IERC20Metadata} from\n  \"../../vendor/openzeppelin-solidity/v4.8.3/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {IERC165} from \"../../vendor/openzeppelin-solidity/v5.0.2/contracts/utils/introspection/IERC165.sol\";\nimport {EnumerableSet} from \"../../vendor/openzeppelin-solidity/v5.0.2/contracts/utils/structs/EnumerableSet.sol\";\n\n/// @dev This pool supports different decimals on different chains but using this feature could impact the total number\n/// of tokens in circulation. Since all of the tokens are locked/burned on the source, and a rounded amount is minted/released on the\n/// destination, the number of tokens minted/released could be less than the number of tokens burned/locked. This is because the source\n/// chain does not know about the destination token decimals. This is not a problem if the decimals are the same on both\n/// chains.\n///\n/// Example:\n/// Assume there is a token with 6 decimals on chain A and 3 decimals on chain B.\n/// - 1.234567 tokens are burned on chain A.\n/// - 1.234    tokens are minted on chain B.\n/// When sending the 1.234 tokens back to chain A, you will receive 1.234000 tokens on chain A, effectively losing\n/// 0.000567 tokens.\n/// In the case of a burnMint pool on chain A, these funds are burned in the pool on chain A.\n/// In the case of a lockRelease pool on chain A, these funds accumulate in the pool on chain A.\nabstract contract TokenPool is IPoolV1, Ownable2StepMsgSender {\n  using EnumerableSet for EnumerableSet.Bytes32Set;\n  using EnumerableSet for EnumerableSet.AddressSet;\n  using EnumerableSet for EnumerableSet.UintSet;\n  using RateLimiter for RateLimiter.TokenBucket;\n\n  error CallerIsNotARampOnRouter(address caller);\n  error ZeroAddressNotAllowed();\n  error SenderNotAllowed(address sender);\n  error AllowListNotEnabled();\n  error NonExistentChain(uint64 remoteChainSelector);\n  error ChainNotAllowed(uint64 remoteChainSelector);\n  error CursedByRMN();\n  error ChainAlreadyExists(uint64 chainSelector);\n  error InvalidSourcePoolAddress(bytes sourcePoolAddress);\n  error InvalidToken(address token);\n  error Unauthorized(address caller);\n  error PoolAlreadyAdded(uint64 remoteChainSelector, bytes remotePoolAddress);\n  error InvalidRemotePoolForChain(uint64 remoteChainSelector, bytes remotePoolAddress);\n  error InvalidRemoteChainDecimals(bytes sourcePoolData);\n  error MismatchedArrayLengths();\n  error OverflowDetected(uint8 remoteDecimals, uint8 localDecimals, uint256 remoteAmount);\n  error InvalidDecimalArgs(uint8 expected, uint8 actual);\n\n  event Locked(address indexed sender, uint256 amount);\n  event Burned(address indexed sender, uint256 amount);\n  event Released(address indexed sender, address indexed recipient, uint256 amount);\n  event Minted(address indexed sender, address indexed recipient, uint256 amount);\n  event ChainAdded(\n    uint64 remoteChainSelector,\n    bytes remoteToken,\n    RateLimiter.Config outboundRateLimiterConfig,\n    RateLimiter.Config inboundRateLimiterConfig\n  );\n  event ChainConfigured(\n    uint64 remoteChainSelector,\n    RateLimiter.Config outboundRateLimiterConfig,\n    RateLimiter.Config inboundRateLimiterConfig\n  );\n  event ChainRemoved(uint64 remoteChainSelector);\n  event RemotePoolAdded(uint64 indexed remoteChainSelector, bytes remotePoolAddress);\n  event RemotePoolRemoved(uint64 indexed remoteChainSelector, bytes remotePoolAddress);\n  event AllowListAdd(address sender);\n  event AllowListRemove(address sender);\n  event RouterUpdated(address oldRouter, address newRouter);\n  event RateLimitAdminSet(address rateLimitAdmin);\n\n  struct ChainUpdate {\n    uint64 remoteChainSelector; // Remote chain selector\n    bytes[] remotePoolAddresses; // Address of the remote pool, ABI encoded in the case of a remote EVM chain.\n    bytes remoteTokenAddress; // Address of the remote token, ABI encoded in the case of a remote EVM chain.\n    RateLimiter.Config outboundRateLimiterConfig; // Outbound rate limited config, meaning the rate limits for all of the onRamps for the given chain\n    RateLimiter.Config inboundRateLimiterConfig; // Inbound rate limited config, meaning the rate limits for all of the offRamps for the given chain\n  }\n\n  struct RemoteChainConfig {\n    RateLimiter.TokenBucket outboundRateLimiterConfig; // Outbound rate limited config, meaning the rate limits for all of the onRamps for the given chain\n    RateLimiter.TokenBucket inboundRateLimiterConfig; // Inbound rate limited config, meaning the rate limits for all of the offRamps for the given chain\n    bytes remoteTokenAddress; // Address of the remote token, ABI encoded in the case of a remote EVM chain.\n    EnumerableSet.Bytes32Set remotePools; // Set of remote pool hashes, ABI encoded in the case of a remote EVM chain.\n  }\n\n  /// @dev The bridgeable token that is managed by this pool. Pools could support multiple tokens at the same time if\n  /// required, but this implementation only supports one token.\n  IERC20 internal immutable i_token;\n  /// @dev The number of decimals of the token managed by this pool.\n  uint8 internal immutable i_tokenDecimals;\n  /// @dev The address of the RMN proxy\n  address internal immutable i_rmnProxy;\n  /// @dev The immutable flag that indicates if the pool is access-controlled.\n  bool internal immutable i_allowlistEnabled;\n  /// @dev A set of addresses allowed to trigger lockOrBurn as original senders.\n  /// Only takes effect if i_allowlistEnabled is true.\n  /// This can be used to ensure only token-issuer specified addresses can move tokens.\n  EnumerableSet.AddressSet internal s_allowlist;\n  /// @dev The address of the router\n  IRouter internal s_router;\n  /// @dev A set of allowed chain selectors. We want the allowlist to be enumerable to\n  /// be able to quickly determine (without parsing logs) who can access the pool.\n  /// @dev The chain selectors are in uint256 format because of the EnumerableSet implementation.\n  EnumerableSet.UintSet internal s_remoteChainSelectors;\n  mapping(uint64 remoteChainSelector => RemoteChainConfig) internal s_remoteChainConfigs;\n  /// @notice A mapping of hashed pool addresses to their unhashed form. This is used to be able to find the actually\n  /// configured pools and not just their hashed versions.\n  mapping(bytes32 poolAddressHash => bytes poolAddress) internal s_remotePoolAddresses;\n  /// @notice The address of the rate limiter admin.\n  /// @dev Can be address(0) if none is configured.\n  address internal s_rateLimitAdmin;\n\n  constructor(IERC20 token, uint8 localTokenDecimals, address[] memory allowlist, address rmnProxy, address router) {\n    if (address(token) == address(0) || router == address(0) || rmnProxy == address(0)) revert ZeroAddressNotAllowed();\n    i_token = token;\n    i_rmnProxy = rmnProxy;\n\n    try IERC20Metadata(address(token)).decimals() returns (uint8 actualTokenDecimals) {\n      if (localTokenDecimals != actualTokenDecimals) {\n        revert InvalidDecimalArgs(localTokenDecimals, actualTokenDecimals);\n      }\n    } catch {\n      // The decimals function doesn't exist, which is possible since it's optional in the ERC20 spec. We skip the check and\n      // assume the supplied token decimals are correct.\n    }\n    i_tokenDecimals = localTokenDecimals;\n\n    s_router = IRouter(router);\n\n    // Pool can be set as permissioned or permissionless at deployment time only to save hot-path gas.\n    i_allowlistEnabled = allowlist.length > 0;\n    if (i_allowlistEnabled) {\n      _applyAllowListUpdates(new address[](0), allowlist);\n    }\n  }\n\n  /// @inheritdoc IPoolV1\n  function isSupportedToken(\n    address token\n  ) public view virtual returns (bool) {\n    return token == address(i_token);\n  }\n\n  /// @notice Gets the IERC20 token that this pool can lock or burn.\n  /// @return token The IERC20 token representation.\n  function getToken() public view returns (IERC20 token) {\n    return i_token;\n  }\n\n  /// @notice Get RMN proxy address\n  /// @return rmnProxy Address of RMN proxy\n  function getRmnProxy() public view returns (address rmnProxy) {\n    return i_rmnProxy;\n  }\n\n  /// @notice Gets the pool's Router\n  /// @return router The pool's Router\n  function getRouter() public view returns (address router) {\n    return address(s_router);\n  }\n\n  /// @notice Sets the pool's Router\n  /// @param newRouter The new Router\n  function setRouter(\n    address newRouter\n  ) public onlyOwner {\n    if (newRouter == address(0)) revert ZeroAddressNotAllowed();\n    address oldRouter = address(s_router);\n    s_router = IRouter(newRouter);\n\n    emit RouterUpdated(oldRouter, newRouter);\n  }\n\n  /// @notice Signals which version of the pool interface is supported\n  function supportsInterface(\n    bytes4 interfaceId\n  ) public pure virtual override returns (bool) {\n    return interfaceId == Pool.CCIP_POOL_V1 || interfaceId == type(IPoolV1).interfaceId\n      || interfaceId == type(IERC165).interfaceId;\n  }\n\n  // ================================================================\n  // │                         Validation                           │\n  // ================================================================\n\n  /// @notice Validates the lock or burn input for correctness on\n  /// - token to be locked or burned\n  /// - RMN curse status\n  /// - allowlist status\n  /// - if the sender is a valid onRamp\n  /// - rate limit status\n  /// @param lockOrBurnIn The input to validate.\n  /// @dev This function should always be called before executing a lock or burn. Not doing so would allow\n  /// for various exploits.\n  function _validateLockOrBurn(\n    Pool.LockOrBurnInV1 calldata lockOrBurnIn\n  ) internal {\n    if (!isSupportedToken(lockOrBurnIn.localToken)) revert InvalidToken(lockOrBurnIn.localToken);\n    if (IRMN(i_rmnProxy).isCursed(bytes16(uint128(lockOrBurnIn.remoteChainSelector)))) revert CursedByRMN();\n    _checkAllowList(lockOrBurnIn.originalSender);\n\n    _onlyOnRamp(lockOrBurnIn.remoteChainSelector);\n    _consumeOutboundRateLimit(lockOrBurnIn.remoteChainSelector, lockOrBurnIn.amount);\n  }\n\n  /// @notice Validates the release or mint input for correctness on\n  /// - token to be released or minted\n  /// - RMN curse status\n  /// - if the sender is a valid offRamp\n  /// - if the source pool is valid\n  /// - rate limit status\n  /// @param releaseOrMintIn The input to validate.\n  /// @dev This function should always be called before executing a release or mint. Not doing so would allow\n  /// for various exploits.\n  function _validateReleaseOrMint(\n    Pool.ReleaseOrMintInV1 calldata releaseOrMintIn\n  ) internal {\n    if (!isSupportedToken(releaseOrMintIn.localToken)) revert InvalidToken(releaseOrMintIn.localToken);\n    if (IRMN(i_rmnProxy).isCursed(bytes16(uint128(releaseOrMintIn.remoteChainSelector)))) revert CursedByRMN();\n    _onlyOffRamp(releaseOrMintIn.remoteChainSelector);\n\n    // Validates that the source pool address is configured on this pool.\n    if (!isRemotePool(releaseOrMintIn.remoteChainSelector, releaseOrMintIn.sourcePoolAddress)) {\n      revert InvalidSourcePoolAddress(releaseOrMintIn.sourcePoolAddress);\n    }\n\n    _consumeInboundRateLimit(releaseOrMintIn.remoteChainSelector, releaseOrMintIn.amount);\n  }\n\n  // ================================================================\n  // │                      Token decimals                          │\n  // ================================================================\n\n  /// @notice Gets the IERC20 token decimals on the local chain.\n  function getTokenDecimals() public view virtual returns (uint8 decimals) {\n    return i_tokenDecimals;\n  }\n\n  function _encodeLocalDecimals() internal view virtual returns (bytes memory) {\n    return abi.encode(i_tokenDecimals);\n  }\n\n  function _parseRemoteDecimals(\n    bytes memory sourcePoolData\n  ) internal view virtual returns (uint8) {\n    // Fallback to the local token decimals if the source pool data is empty. This allows for backwards compatibility.\n    if (sourcePoolData.length == 0) {\n      return i_tokenDecimals;\n    }\n    if (sourcePoolData.length != 32) {\n      revert InvalidRemoteChainDecimals(sourcePoolData);\n    }\n    uint256 remoteDecimals = abi.decode(sourcePoolData, (uint256));\n    if (remoteDecimals > type(uint8).max) {\n      revert InvalidRemoteChainDecimals(sourcePoolData);\n    }\n    return uint8(remoteDecimals);\n  }\n\n  /// @notice Calculates the local amount based on the remote amount and decimals.\n  /// @param remoteAmount The amount on the remote chain.\n  /// @param remoteDecimals The decimals of the token on the remote chain.\n  /// @return The local amount.\n  /// @dev This function protects against overflows. If there is a transaction that hits the overflow check, it is\n  /// probably incorrect as that means the amount cannot be represented on this chain. If the local decimals have been\n  /// wrongly configured, the token issuer could redeploy the pool with the correct decimals and manually re-execute the\n  /// CCIP tx to fix the issue.\n  function _calculateLocalAmount(uint256 remoteAmount, uint8 remoteDecimals) internal view virtual returns (uint256) {\n    if (remoteDecimals == i_tokenDecimals) {\n      return remoteAmount;\n    }\n    if (remoteDecimals > i_tokenDecimals) {\n      uint8 decimalsDiff = remoteDecimals - i_tokenDecimals;\n      if (decimalsDiff > 77) {\n        // This is a safety check to prevent overflow in the next calculation.\n        revert OverflowDetected(remoteDecimals, i_tokenDecimals, remoteAmount);\n      }\n      // Solidity rounds down so there is no risk of minting more tokens than the remote chain sent.\n      return remoteAmount / (10 ** decimalsDiff);\n    }\n\n    // This is a safety check to prevent overflow in the next calculation.\n    // More than 77 would never fit in a uint256 and would cause an overflow. We also check if the resulting amount\n    // would overflow.\n    uint8 diffDecimals = i_tokenDecimals - remoteDecimals;\n    if (diffDecimals > 77 || remoteAmount > type(uint256).max / (10 ** diffDecimals)) {\n      revert OverflowDetected(remoteDecimals, i_tokenDecimals, remoteAmount);\n    }\n\n    return remoteAmount * (10 ** diffDecimals);\n  }\n\n  // ================================================================\n  // │                     Chain permissions                        │\n  // ================================================================\n\n  /// @notice Gets the pool address on the remote chain.\n  /// @param remoteChainSelector Remote chain selector.\n  /// @dev To support non-evm chains, this value is encoded into bytes\n  function getRemotePools(\n    uint64 remoteChainSelector\n  ) public view returns (bytes[] memory) {\n    bytes32[] memory remotePoolHashes = s_remoteChainConfigs[remoteChainSelector].remotePools.values();\n\n    bytes[] memory remotePools = new bytes[](remotePoolHashes.length);\n    for (uint256 i = 0; i < remotePoolHashes.length; ++i) {\n      remotePools[i] = s_remotePoolAddresses[remotePoolHashes[i]];\n    }\n\n    return remotePools;\n  }\n\n  /// @notice Checks if the pool address is configured on the remote chain.\n  /// @param remoteChainSelector Remote chain selector.\n  /// @param remotePoolAddress The address of the remote pool.\n  function isRemotePool(uint64 remoteChainSelector, bytes calldata remotePoolAddress) public view returns (bool) {\n    return s_remoteChainConfigs[remoteChainSelector].remotePools.contains(keccak256(remotePoolAddress));\n  }\n\n  /// @notice Gets the token address on the remote chain.\n  /// @param remoteChainSelector Remote chain selector.\n  /// @dev To support non-evm chains, this value is encoded into bytes\n  function getRemoteToken(\n    uint64 remoteChainSelector\n  ) public view returns (bytes memory) {\n    return s_remoteChainConfigs[remoteChainSelector].remoteTokenAddress;\n  }\n\n  /// @notice Adds a remote pool for a given chain selector. This could be due to a pool being upgraded on the remote\n  /// chain. We don't simply want to replace the old pool as there could still be valid inflight messages from the old\n  /// pool. This function allows for multiple pools to be added for a single chain selector.\n  /// @param remoteChainSelector The remote chain selector for which the remote pool address is being added.\n  /// @param remotePoolAddress The address of the new remote pool.\n  function addRemotePool(uint64 remoteChainSelector, bytes calldata remotePoolAddress) external onlyOwner {\n    if (!isSupportedChain(remoteChainSelector)) revert NonExistentChain(remoteChainSelector);\n\n    _setRemotePool(remoteChainSelector, remotePoolAddress);\n  }\n\n  /// @notice Removes the remote pool address for a given chain selector.\n  /// @dev All inflight txs from the remote pool will be rejected after it is removed. To ensure no loss of funds, there\n  /// should be no inflight txs from the given pool.\n  function removeRemotePool(uint64 remoteChainSelector, bytes calldata remotePoolAddress) external onlyOwner {\n    if (!isSupportedChain(remoteChainSelector)) revert NonExistentChain(remoteChainSelector);\n\n    if (!s_remoteChainConfigs[remoteChainSelector].remotePools.remove(keccak256(remotePoolAddress))) {\n      revert InvalidRemotePoolForChain(remoteChainSelector, remotePoolAddress);\n    }\n\n    emit RemotePoolRemoved(remoteChainSelector, remotePoolAddress);\n  }\n\n  /// @inheritdoc IPoolV1\n  function isSupportedChain(\n    uint64 remoteChainSelector\n  ) public view returns (bool) {\n    return s_remoteChainSelectors.contains(remoteChainSelector);\n  }\n\n  /// @notice Get list of allowed chains\n  /// @return list of chains.\n  function getSupportedChains() public view returns (uint64[] memory) {\n    uint256[] memory uint256ChainSelectors = s_remoteChainSelectors.values();\n    uint64[] memory chainSelectors = new uint64[](uint256ChainSelectors.length);\n    for (uint256 i = 0; i < uint256ChainSelectors.length; ++i) {\n      chainSelectors[i] = uint64(uint256ChainSelectors[i]);\n    }\n\n    return chainSelectors;\n  }\n\n  /// @notice Sets the permissions for a list of chains selectors. Actual senders for these chains\n  /// need to be allowed on the Router to interact with this pool.\n  /// @param remoteChainSelectorsToRemove A list of chain selectors to remove.\n  /// @param chainsToAdd A list of chains and their new permission status & rate limits. Rate limits\n  /// are only used when the chain is being added through `allowed` being true.\n  /// @dev Only callable by the owner\n  function applyChainUpdates(\n    uint64[] calldata remoteChainSelectorsToRemove,\n    ChainUpdate[] calldata chainsToAdd\n  ) external virtual onlyOwner {\n    for (uint256 i = 0; i < remoteChainSelectorsToRemove.length; ++i) {\n      uint64 remoteChainSelectorToRemove = remoteChainSelectorsToRemove[i];\n      // If the chain doesn't exist, revert\n      if (!s_remoteChainSelectors.remove(remoteChainSelectorToRemove)) {\n        revert NonExistentChain(remoteChainSelectorToRemove);\n      }\n\n      // Remove all remote pool hashes for the chain\n      bytes32[] memory remotePools = s_remoteChainConfigs[remoteChainSelectorToRemove].remotePools.values();\n      for (uint256 j = 0; j < remotePools.length; ++j) {\n        s_remoteChainConfigs[remoteChainSelectorToRemove].remotePools.remove(remotePools[j]);\n      }\n\n      delete s_remoteChainConfigs[remoteChainSelectorToRemove];\n\n      emit ChainRemoved(remoteChainSelectorToRemove);\n    }\n\n    for (uint256 i = 0; i < chainsToAdd.length; ++i) {\n      ChainUpdate memory newChain = chainsToAdd[i];\n      RateLimiter._validateTokenBucketConfig(newChain.outboundRateLimiterConfig, false);\n      RateLimiter._validateTokenBucketConfig(newChain.inboundRateLimiterConfig, false);\n\n      if (newChain.remoteTokenAddress.length == 0) {\n        revert ZeroAddressNotAllowed();\n      }\n\n      // If the chain already exists, revert\n      if (!s_remoteChainSelectors.add(newChain.remoteChainSelector)) {\n        revert ChainAlreadyExists(newChain.remoteChainSelector);\n      }\n\n      RemoteChainConfig storage remoteChainConfig = s_remoteChainConfigs[newChain.remoteChainSelector];\n\n      remoteChainConfig.outboundRateLimiterConfig = RateLimiter.TokenBucket({\n        rate: newChain.outboundRateLimiterConfig.rate,\n        capacity: newChain.outboundRateLimiterConfig.capacity,\n        tokens: newChain.outboundRateLimiterConfig.capacity,\n        lastUpdated: uint32(block.timestamp),\n        isEnabled: newChain.outboundRateLimiterConfig.isEnabled\n      });\n      remoteChainConfig.inboundRateLimiterConfig = RateLimiter.TokenBucket({\n        rate: newChain.inboundRateLimiterConfig.rate,\n        capacity: newChain.inboundRateLimiterConfig.capacity,\n        tokens: newChain.inboundRateLimiterConfig.capacity,\n        lastUpdated: uint32(block.timestamp),\n        isEnabled: newChain.inboundRateLimiterConfig.isEnabled\n      });\n      remoteChainConfig.remoteTokenAddress = newChain.remoteTokenAddress;\n\n      for (uint256 j = 0; j < newChain.remotePoolAddresses.length; ++j) {\n        _setRemotePool(newChain.remoteChainSelector, newChain.remotePoolAddresses[j]);\n      }\n\n      emit ChainAdded(\n        newChain.remoteChainSelector,\n        newChain.remoteTokenAddress,\n        newChain.outboundRateLimiterConfig,\n        newChain.inboundRateLimiterConfig\n      );\n    }\n  }\n\n  /// @notice Adds a pool address to the allowed remote token pools for a particular chain.\n  /// @param remoteChainSelector The remote chain selector for which the remote pool address is being added.\n  /// @param remotePoolAddress The address of the new remote pool.\n  function _setRemotePool(uint64 remoteChainSelector, bytes memory remotePoolAddress) internal {\n    if (remotePoolAddress.length == 0) {\n      revert ZeroAddressNotAllowed();\n    }\n\n    bytes32 poolHash = keccak256(remotePoolAddress);\n\n    // Check if the pool already exists.\n    if (!s_remoteChainConfigs[remoteChainSelector].remotePools.add(poolHash)) {\n      revert PoolAlreadyAdded(remoteChainSelector, remotePoolAddress);\n    }\n\n    // Add the pool to the mapping to be able to un-hash it later.\n    s_remotePoolAddresses[poolHash] = remotePoolAddress;\n\n    emit RemotePoolAdded(remoteChainSelector, remotePoolAddress);\n  }\n\n  // ================================================================\n  // │                        Rate limiting                         │\n  // ================================================================\n\n  /// @dev The inbound rate limits should be slightly higher than the outbound rate limits. This is because many chains\n  /// finalize blocks in batches. CCIP also commits messages in batches: the commit plugin bundles multiple messages in\n  /// a single merkle root.\n  /// Imagine the following scenario.\n  /// - Chain A has an inbound and outbound rate limit of 100 tokens capacity and 1 token per second refill rate.\n  /// - Chain B has an inbound and outbound rate limit of 100 tokens capacity and 1 token per second refill rate.\n  ///\n  /// At time 0:\n  /// - Chain A sends 100 tokens to Chain B.\n  /// At time 5:\n  /// - Chain A sends 5 tokens to Chain B.\n  /// At time 6:\n  /// The epoch that contains blocks [0-5] is finalized.\n  /// Both transactions will be included in the same merkle root and become executable at the same time. This means\n  /// the token pool on chain B requires a capacity of 105 to successfully execute both messages at the same time.\n  /// The exact additional capacity required depends on the refill rate and the size of the source chain epochs and the\n  /// CCIP round time. For simplicity, a 5-10% buffer should be sufficient in most cases.\n\n  /// @notice Sets the rate limiter admin address.\n  /// @dev Only callable by the owner.\n  /// @param rateLimitAdmin The new rate limiter admin address.\n  function setRateLimitAdmin(\n    address rateLimitAdmin\n  ) external onlyOwner {\n    s_rateLimitAdmin = rateLimitAdmin;\n    emit RateLimitAdminSet(rateLimitAdmin);\n  }\n\n  /// @notice Gets the rate limiter admin address.\n  function getRateLimitAdmin() external view returns (address) {\n    return s_rateLimitAdmin;\n  }\n\n  /// @notice Consumes outbound rate limiting capacity in this pool\n  function _consumeOutboundRateLimit(uint64 remoteChainSelector, uint256 amount) internal {\n    s_remoteChainConfigs[remoteChainSelector].outboundRateLimiterConfig._consume(amount, address(i_token));\n  }\n\n  /// @notice Consumes inbound rate limiting capacity in this pool\n  function _consumeInboundRateLimit(uint64 remoteChainSelector, uint256 amount) internal {\n    s_remoteChainConfigs[remoteChainSelector].inboundRateLimiterConfig._consume(amount, address(i_token));\n  }\n\n  /// @notice Gets the token bucket with its values for the block it was requested at.\n  /// @return The token bucket.\n  function getCurrentOutboundRateLimiterState(\n    uint64 remoteChainSelector\n  ) external view returns (RateLimiter.TokenBucket memory) {\n    return s_remoteChainConfigs[remoteChainSelector].outboundRateLimiterConfig._currentTokenBucketState();\n  }\n\n  /// @notice Gets the token bucket with its values for the block it was requested at.\n  /// @return The token bucket.\n  function getCurrentInboundRateLimiterState(\n    uint64 remoteChainSelector\n  ) external view returns (RateLimiter.TokenBucket memory) {\n    return s_remoteChainConfigs[remoteChainSelector].inboundRateLimiterConfig._currentTokenBucketState();\n  }\n\n  /// @notice Sets multiple chain rate limiter configs.\n  /// @param remoteChainSelectors The remote chain selector for which the rate limits apply.\n  /// @param outboundConfigs The new outbound rate limiter config, meaning the onRamp rate limits for the given chain.\n  /// @param inboundConfigs The new inbound rate limiter config, meaning the offRamp rate limits for the given chain.\n  function setChainRateLimiterConfigs(\n    uint64[] calldata remoteChainSelectors,\n    RateLimiter.Config[] calldata outboundConfigs,\n    RateLimiter.Config[] calldata inboundConfigs\n  ) external {\n    if (msg.sender != s_rateLimitAdmin && msg.sender != owner()) revert Unauthorized(msg.sender);\n    if (remoteChainSelectors.length != outboundConfigs.length || remoteChainSelectors.length != inboundConfigs.length) {\n      revert MismatchedArrayLengths();\n    }\n\n    for (uint256 i = 0; i < remoteChainSelectors.length; ++i) {\n      _setRateLimitConfig(remoteChainSelectors[i], outboundConfigs[i], inboundConfigs[i]);\n    }\n  }\n\n  /// @notice Sets the chain rate limiter config.\n  /// @param remoteChainSelector The remote chain selector for which the rate limits apply.\n  /// @param outboundConfig The new outbound rate limiter config, meaning the onRamp rate limits for the given chain.\n  /// @param inboundConfig The new inbound rate limiter config, meaning the offRamp rate limits for the given chain.\n  function setChainRateLimiterConfig(\n    uint64 remoteChainSelector,\n    RateLimiter.Config memory outboundConfig,\n    RateLimiter.Config memory inboundConfig\n  ) external {\n    if (msg.sender != s_rateLimitAdmin && msg.sender != owner()) revert Unauthorized(msg.sender);\n\n    _setRateLimitConfig(remoteChainSelector, outboundConfig, inboundConfig);\n  }\n\n  function _setRateLimitConfig(\n    uint64 remoteChainSelector,\n    RateLimiter.Config memory outboundConfig,\n    RateLimiter.Config memory inboundConfig\n  ) internal {\n    if (!isSupportedChain(remoteChainSelector)) revert NonExistentChain(remoteChainSelector);\n    RateLimiter._validateTokenBucketConfig(outboundConfig, false);\n    s_remoteChainConfigs[remoteChainSelector].outboundRateLimiterConfig._setTokenBucketConfig(outboundConfig);\n    RateLimiter._validateTokenBucketConfig(inboundConfig, false);\n    s_remoteChainConfigs[remoteChainSelector].inboundRateLimiterConfig._setTokenBucketConfig(inboundConfig);\n    emit ChainConfigured(remoteChainSelector, outboundConfig, inboundConfig);\n  }\n\n  // ================================================================\n  // │                           Access                             │\n  // ================================================================\n\n  /// @notice Checks whether remote chain selector is configured on this contract, and if the msg.sender\n  /// is a permissioned onRamp for the given chain on the Router.\n  function _onlyOnRamp(\n    uint64 remoteChainSelector\n  ) internal view {\n    if (!isSupportedChain(remoteChainSelector)) revert ChainNotAllowed(remoteChainSelector);\n    if (!(msg.sender == s_router.getOnRamp(remoteChainSelector))) revert CallerIsNotARampOnRouter(msg.sender);\n  }\n\n  /// @notice Checks whether remote chain selector is configured on this contract, and if the msg.sender\n  /// is a permissioned offRamp for the given chain on the Router.\n  function _onlyOffRamp(\n    uint64 remoteChainSelector\n  ) internal view {\n    if (!isSupportedChain(remoteChainSelector)) revert ChainNotAllowed(remoteChainSelector);\n    if (!s_router.isOffRamp(remoteChainSelector, msg.sender)) revert CallerIsNotARampOnRouter(msg.sender);\n  }\n\n  // ================================================================\n  // │                          Allowlist                           │\n  // ================================================================\n\n  function _checkAllowList(\n    address sender\n  ) internal view {\n    if (i_allowlistEnabled) {\n      if (!s_allowlist.contains(sender)) {\n        revert SenderNotAllowed(sender);\n      }\n    }\n  }\n\n  /// @notice Gets whether the allowlist functionality is enabled.\n  /// @return true is enabled, false if not.\n  function getAllowListEnabled() external view returns (bool) {\n    return i_allowlistEnabled;\n  }\n\n  /// @notice Gets the allowed addresses.\n  /// @return The allowed addresses.\n  function getAllowList() external view returns (address[] memory) {\n    return s_allowlist.values();\n  }\n\n  /// @notice Apply updates to the allow list.\n  /// @param removes The addresses to be removed.\n  /// @param adds The addresses to be added.\n  function applyAllowListUpdates(address[] calldata removes, address[] calldata adds) external onlyOwner {\n    _applyAllowListUpdates(removes, adds);\n  }\n\n  /// @notice Internal version of applyAllowListUpdates to allow for reuse in the constructor.\n  function _applyAllowListUpdates(address[] memory removes, address[] memory adds) internal {\n    if (!i_allowlistEnabled) revert AllowListNotEnabled();\n\n    for (uint256 i = 0; i < removes.length; ++i) {\n      address toRemove = removes[i];\n      if (s_allowlist.remove(toRemove)) {\n        emit AllowListRemove(toRemove);\n      }\n    }\n    for (uint256 i = 0; i < adds.length; ++i) {\n      address toAdd = adds[i];\n      if (toAdd == address(0)) {\n        continue;\n      }\n      if (s_allowlist.add(toAdd)) {\n        emit AllowListAdd(toAdd);\n      }\n    }\n  }\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/ccip/tokenAdminRegistry/RegistryModuleOwnerCustom.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.24;\n\nimport {ITypeAndVersion} from \"../../shared/interfaces/ITypeAndVersion.sol\";\nimport {IGetCCIPAdmin} from \"../interfaces/IGetCCIPAdmin.sol\";\nimport {IOwner} from \"../interfaces/IOwner.sol\";\nimport {ITokenAdminRegistry} from \"../interfaces/ITokenAdminRegistry.sol\";\n\nimport {AccessControl} from \"../../vendor/openzeppelin-solidity/v5.0.2/contracts/access/AccessControl.sol\";\n\ncontract RegistryModuleOwnerCustom is ITypeAndVersion {\n  error CanOnlySelfRegister(address admin, address token);\n  error RequiredRoleNotFound(address msgSender, bytes32 role, address token);\n  error AddressZero();\n\n  event AdministratorRegistered(address indexed token, address indexed administrator);\n\n  string public constant override typeAndVersion = \"RegistryModuleOwnerCustom 1.6.0\";\n\n  // The TokenAdminRegistry contract\n  ITokenAdminRegistry internal immutable i_tokenAdminRegistry;\n\n  constructor(\n    address tokenAdminRegistry\n  ) {\n    if (tokenAdminRegistry == address(0)) {\n      revert AddressZero();\n    }\n    i_tokenAdminRegistry = ITokenAdminRegistry(tokenAdminRegistry);\n  }\n\n  /// @notice Registers the admin of the token using the `getCCIPAdmin` method.\n  /// @param token The token to register the admin for.\n  /// @dev The caller must be the admin returned by the `getCCIPAdmin` method.\n  function registerAdminViaGetCCIPAdmin(\n    address token\n  ) external {\n    _registerAdmin(token, IGetCCIPAdmin(token).getCCIPAdmin());\n  }\n\n  /// @notice Registers the admin of the token using the `owner` method.\n  /// @param token The token to register the admin for.\n  /// @dev The caller must be the admin returned by the `owner` method.\n  function registerAdminViaOwner(\n    address token\n  ) external {\n    _registerAdmin(token, IOwner(token).owner());\n  }\n\n  /// @notice Registers the admin of the token using OZ's AccessControl DEFAULT_ADMIN_ROLE.\n  /// @param token The token to register the admin for.\n  /// @dev The caller must have the DEFAULT_ADMIN_ROLE as defined by the contract itself.\n  function registerAccessControlDefaultAdmin(\n    address token\n  ) external {\n    bytes32 defaultAdminRole = AccessControl(token).DEFAULT_ADMIN_ROLE();\n    if (!AccessControl(token).hasRole(defaultAdminRole, msg.sender)) {\n      revert RequiredRoleNotFound(msg.sender, defaultAdminRole, token);\n    }\n\n    _registerAdmin(token, msg.sender);\n  }\n\n  /// @notice Registers the admin of the token to msg.sender given that the\n  /// admin is equal to msg.sender.\n  /// @param token The token to register the admin for.\n  /// @param admin The caller must be the admin.\n  function _registerAdmin(address token, address admin) internal {\n    if (admin != msg.sender) {\n      revert CanOnlySelfRegister(admin, token);\n    }\n\n    i_tokenAdminRegistry.proposeAdministrator(token, admin);\n\n    emit AdministratorRegistered(token, admin);\n  }\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/ccip/tokenAdminRegistry/TokenAdminRegistry.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.24;\n\nimport {ITypeAndVersion} from \"../../shared/interfaces/ITypeAndVersion.sol\";\nimport {IPoolV1} from \"../interfaces/IPool.sol\";\nimport {ITokenAdminRegistry} from \"../interfaces/ITokenAdminRegistry.sol\";\n\nimport {OwnerIsCreator} from \"../../shared/access/OwnerIsCreator.sol\";\n\nimport {EnumerableSet} from \"../../vendor/openzeppelin-solidity/v5.0.2/contracts/utils/structs/EnumerableSet.sol\";\n\n/// @notice This contract stores the token pool configuration for all CCIP enabled tokens. It works\n/// on a self-serve basis, where tokens can be registered without intervention from the CCIP owner.\n/// @dev This contract is not considered upgradable, as it is a customer facing contract that will store\n/// significant amounts of data.\ncontract TokenAdminRegistry is ITokenAdminRegistry, ITypeAndVersion, OwnerIsCreator {\n  using EnumerableSet for EnumerableSet.AddressSet;\n\n  error OnlyRegistryModuleOrOwner(address sender);\n  error OnlyAdministrator(address sender, address token);\n  error OnlyPendingAdministrator(address sender, address token);\n  error AlreadyRegistered(address token);\n  error ZeroAddress();\n  error InvalidTokenPoolToken(address token);\n\n  event PoolSet(address indexed token, address indexed previousPool, address indexed newPool);\n  event AdministratorTransferRequested(address indexed token, address indexed currentAdmin, address indexed newAdmin);\n  event AdministratorTransferred(address indexed token, address indexed newAdmin);\n  event RegistryModuleAdded(address module);\n  event RegistryModuleRemoved(address indexed module);\n\n  // The struct is packed in a way that optimizes the attributes that are accessed together.\n  // solhint-disable-next-line gas-struct-packing\n  struct TokenConfig {\n    address administrator; // the current administrator of the token\n    address pendingAdministrator; // the address that is pending to become the new administrator\n    address tokenPool; // the token pool for this token. Can be address(0) if not deployed or not configured.\n  }\n\n  string public constant override typeAndVersion = \"TokenAdminRegistry 1.5.0\";\n\n  // Mapping of token address to token configuration\n  mapping(address token => TokenConfig) internal s_tokenConfig;\n\n  // All tokens that have been configured\n  EnumerableSet.AddressSet internal s_tokens;\n\n  // Registry modules are allowed to register administrators for tokens\n  EnumerableSet.AddressSet internal s_registryModules;\n\n  /// @notice Returns all pools for the given tokens.\n  /// @dev Will return address(0) for tokens that do not have a pool.\n  function getPools(\n    address[] calldata tokens\n  ) external view returns (address[] memory) {\n    address[] memory pools = new address[](tokens.length);\n    for (uint256 i = 0; i < tokens.length; ++i) {\n      pools[i] = s_tokenConfig[tokens[i]].tokenPool;\n    }\n    return pools;\n  }\n\n  /// @inheritdoc ITokenAdminRegistry\n  function getPool(\n    address token\n  ) external view returns (address) {\n    return s_tokenConfig[token].tokenPool;\n  }\n\n  /// @notice Returns the configuration for a token.\n  /// @param token The token to get the configuration for.\n  /// @return config The configuration for the token.\n  function getTokenConfig(\n    address token\n  ) external view returns (TokenConfig memory) {\n    return s_tokenConfig[token];\n  }\n\n  /// @notice Returns a list of tokens that are configured in the token admin registry.\n  /// @param startIndex Starting index in list, can be 0 if you want to start from the beginning.\n  /// @param maxCount Maximum number of tokens to retrieve. Since the list can be large,\n  /// it is recommended to use a paging mechanism to retrieve all tokens. If querying for very\n  /// large lists, RPCs can time out. If you want all tokens, use type(uint64).max.\n  /// @return tokens List of configured tokens.\n  /// @dev The function is paginated to avoid RPC timeouts.\n  /// @dev The ordering is guaranteed to remain the same as it is not possible to remove tokens\n  /// from s_tokens.\n  function getAllConfiguredTokens(uint64 startIndex, uint64 maxCount) external view returns (address[] memory tokens) {\n    uint256 numberOfTokens = s_tokens.length();\n    if (startIndex >= numberOfTokens) {\n      return tokens;\n    }\n    uint256 count = maxCount;\n    if (count + startIndex > numberOfTokens) {\n      count = numberOfTokens - startIndex;\n    }\n    tokens = new address[](count);\n    for (uint256 i = 0; i < count; ++i) {\n      tokens[i] = s_tokens.at(startIndex + i);\n    }\n\n    return tokens;\n  }\n\n  // ================================================================\n  // │                  Administrator functions                     │\n  // ================================================================\n\n  /// @notice Sets the pool for a token. Setting the pool to address(0) effectively delists the token\n  /// from CCIP. Setting the pool to any other address enables the token on CCIP.\n  /// @param localToken The token to set the pool for.\n  /// @param pool The pool to set for the token.\n  function setPool(address localToken, address pool) external onlyTokenAdmin(localToken) {\n    // The pool has to support the token, but we want to allow removing the pool, so we only check\n    // if the pool supports the token if it is not address(0).\n    if (pool != address(0) && !IPoolV1(pool).isSupportedToken(localToken)) {\n      revert InvalidTokenPoolToken(localToken);\n    }\n\n    TokenConfig storage config = s_tokenConfig[localToken];\n\n    address previousPool = config.tokenPool;\n    config.tokenPool = pool;\n\n    if (previousPool != pool) {\n      emit PoolSet(localToken, previousPool, pool);\n    }\n  }\n\n  /// @notice Transfers the administrator role for a token to a new address with a 2-step process.\n  /// @param localToken The token to transfer the administrator role for.\n  /// @param newAdmin The address to transfer the administrator role to. Can be address(0) to cancel\n  /// a pending transfer.\n  /// @dev The new admin must call `acceptAdminRole` to accept the role.\n  function transferAdminRole(address localToken, address newAdmin) external onlyTokenAdmin(localToken) {\n    TokenConfig storage config = s_tokenConfig[localToken];\n    config.pendingAdministrator = newAdmin;\n\n    emit AdministratorTransferRequested(localToken, msg.sender, newAdmin);\n  }\n\n  /// @notice Accepts the administrator role for a token.\n  /// @param localToken The token to accept the administrator role for.\n  /// @dev This function can only be called by the pending administrator.\n  function acceptAdminRole(\n    address localToken\n  ) external {\n    TokenConfig storage config = s_tokenConfig[localToken];\n    if (config.pendingAdministrator != msg.sender) {\n      revert OnlyPendingAdministrator(msg.sender, localToken);\n    }\n\n    config.administrator = msg.sender;\n    config.pendingAdministrator = address(0);\n\n    emit AdministratorTransferred(localToken, msg.sender);\n  }\n\n  // ================================================================\n  // │                    Administrator config                      │\n  // ================================================================\n\n  /// @notice Public getter to check for permissions of an administrator\n  function isAdministrator(address localToken, address administrator) external view returns (bool) {\n    return s_tokenConfig[localToken].administrator == administrator;\n  }\n\n  /// @inheritdoc ITokenAdminRegistry\n  /// @dev Can only be called by a registry module.\n  function proposeAdministrator(address localToken, address administrator) external {\n    if (!isRegistryModule(msg.sender) && msg.sender != owner()) {\n      revert OnlyRegistryModuleOrOwner(msg.sender);\n    }\n    if (administrator == address(0)) {\n      revert ZeroAddress();\n    }\n    TokenConfig storage config = s_tokenConfig[localToken];\n\n    if (config.administrator != address(0)) {\n      revert AlreadyRegistered(localToken);\n    }\n\n    config.pendingAdministrator = administrator;\n\n    // We don't care if it's already in the set, as it's a no-op.\n    s_tokens.add(localToken);\n\n    emit AdministratorTransferRequested(localToken, address(0), administrator);\n  }\n\n  // ================================================================\n  // │                      Registry Modules                        │\n  // ================================================================\n\n  /// @notice Checks if an address is a registry module.\n  /// @param module The address to check.\n  /// @return True if the address is a registry module, false otherwise.\n  function isRegistryModule(\n    address module\n  ) public view returns (bool) {\n    return s_registryModules.contains(module);\n  }\n\n  /// @notice Adds a new registry module to the list of allowed modules.\n  /// @param module The module to add.\n  function addRegistryModule(\n    address module\n  ) external onlyOwner {\n    if (s_registryModules.add(module)) {\n      emit RegistryModuleAdded(module);\n    }\n  }\n\n  /// @notice Removes a registry module from the list of allowed modules.\n  /// @param module The module to remove.\n  function removeRegistryModule(\n    address module\n  ) external onlyOwner {\n    if (s_registryModules.remove(module)) {\n      emit RegistryModuleRemoved(module);\n    }\n  }\n\n  // ================================================================\n  // │                           Access                             │\n  // ================================================================\n\n  /// @notice Checks if an address is the administrator of the given token.\n  modifier onlyTokenAdmin(\n    address token\n  ) {\n    if (s_tokenConfig[token].administrator != msg.sender) {\n      revert OnlyAdministrator(msg.sender, token);\n    }\n    _;\n  }\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/shared/access/ConfirmedOwner.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {ConfirmedOwnerWithProposal} from \"./ConfirmedOwnerWithProposal.sol\";\n\n/// @title The ConfirmedOwner contract\n/// @notice A contract with helpers for basic contract ownership.\ncontract ConfirmedOwner is ConfirmedOwnerWithProposal {\n  constructor(address newOwner) ConfirmedOwnerWithProposal(newOwner, address(0)) {}\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/shared/access/ConfirmedOwnerWithProposal.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IOwnable} from \"../interfaces/IOwnable.sol\";\n\n/// @title The ConfirmedOwner contract\n/// @notice A contract with helpers for basic contract ownership.\ncontract ConfirmedOwnerWithProposal is IOwnable {\n  address private s_owner;\n  address private s_pendingOwner;\n\n  event OwnershipTransferRequested(address indexed from, address indexed to);\n  event OwnershipTransferred(address indexed from, address indexed to);\n\n  constructor(address newOwner, address pendingOwner) {\n    // solhint-disable-next-line gas-custom-errors\n    require(newOwner != address(0), \"Cannot set owner to zero\");\n\n    s_owner = newOwner;\n    if (pendingOwner != address(0)) {\n      _transferOwnership(pendingOwner);\n    }\n  }\n\n  /// @notice Allows an owner to begin transferring ownership to a new address.\n  function transferOwnership(address to) public override onlyOwner {\n    _transferOwnership(to);\n  }\n\n  /// @notice Allows an ownership transfer to be completed by the recipient.\n  function acceptOwnership() external override {\n    // solhint-disable-next-line gas-custom-errors\n    require(msg.sender == s_pendingOwner, \"Must be proposed owner\");\n\n    address oldOwner = s_owner;\n    s_owner = msg.sender;\n    s_pendingOwner = address(0);\n\n    emit OwnershipTransferred(oldOwner, msg.sender);\n  }\n\n  /// @notice Get the current owner\n  function owner() public view override returns (address) {\n    return s_owner;\n  }\n\n  /// @notice validate, transfer ownership, and emit relevant events\n  function _transferOwnership(address to) private {\n    // solhint-disable-next-line gas-custom-errors\n    require(to != msg.sender, \"Cannot transfer to self\");\n\n    s_pendingOwner = to;\n\n    emit OwnershipTransferRequested(s_owner, to);\n  }\n\n  /// @notice validate access\n  function _validateOwnership() internal view {\n    // solhint-disable-next-line gas-custom-errors\n    require(msg.sender == s_owner, \"Only callable by owner\");\n  }\n\n  /// @notice Reverts if called by anyone other than the contract owner.\n  modifier onlyOwner() {\n    _validateOwnership();\n    _;\n  }\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/shared/access/Ownable2Step.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport {IOwnable} from \"../interfaces/IOwnable.sol\";\n\n/// @notice A minimal contract that implements 2-step ownership transfer and nothing more. It's made to be minimal\n/// to reduce the impact of the bytecode size on any contract that inherits from it.\ncontract Ownable2Step is IOwnable {\n  /// @notice The pending owner is the address to which ownership may be transferred.\n  address private s_pendingOwner;\n  /// @notice The owner is the current owner of the contract.\n  /// @dev The owner is the second storage variable so any implementing contract could pack other state with it\n  /// instead of the much less used s_pendingOwner.\n  address private s_owner;\n\n  error OwnerCannotBeZero();\n  error MustBeProposedOwner();\n  error CannotTransferToSelf();\n  error OnlyCallableByOwner();\n\n  event OwnershipTransferRequested(address indexed from, address indexed to);\n  event OwnershipTransferred(address indexed from, address indexed to);\n\n  constructor(address newOwner, address pendingOwner) {\n    if (newOwner == address(0)) {\n      revert OwnerCannotBeZero();\n    }\n\n    s_owner = newOwner;\n    if (pendingOwner != address(0)) {\n      _transferOwnership(pendingOwner);\n    }\n  }\n\n  /// @notice Get the current owner\n  function owner() public view override returns (address) {\n    return s_owner;\n  }\n\n  /// @notice Allows an owner to begin transferring ownership to a new address. The new owner needs to call\n  /// `acceptOwnership` to accept the transfer before any permissions are changed.\n  /// @param to The address to which ownership will be transferred.\n  function transferOwnership(address to) public override onlyOwner {\n    _transferOwnership(to);\n  }\n\n  /// @notice validate, transfer ownership, and emit relevant events\n  /// @param to The address to which ownership will be transferred.\n  function _transferOwnership(address to) private {\n    if (to == msg.sender) {\n      revert CannotTransferToSelf();\n    }\n\n    s_pendingOwner = to;\n\n    emit OwnershipTransferRequested(s_owner, to);\n  }\n\n  /// @notice Allows an ownership transfer to be completed by the recipient.\n  function acceptOwnership() external override {\n    if (msg.sender != s_pendingOwner) {\n      revert MustBeProposedOwner();\n    }\n\n    address oldOwner = s_owner;\n    s_owner = msg.sender;\n    s_pendingOwner = address(0);\n\n    emit OwnershipTransferred(oldOwner, msg.sender);\n  }\n\n  /// @notice validate access\n  function _validateOwnership() internal view {\n    if (msg.sender != s_owner) {\n      revert OnlyCallableByOwner();\n    }\n  }\n\n  /// @notice Reverts if called by anyone other than the contract owner.\n  modifier onlyOwner() {\n    _validateOwnership();\n    _;\n  }\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/shared/access/Ownable2StepMsgSender.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport {Ownable2Step} from \"./Ownable2Step.sol\";\n\n/// @notice Sets the msg.sender to be the owner of the contract and does not set a pending owner.\ncontract Ownable2StepMsgSender is Ownable2Step {\n  constructor() Ownable2Step(msg.sender, address(0)) {}\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/shared/access/OwnerIsCreator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {ConfirmedOwner} from \"./ConfirmedOwner.sol\";\n\n/// @title The OwnerIsCreator contract\n/// @notice A contract with helpers for basic contract ownership.\ncontract OwnerIsCreator is ConfirmedOwner {\n  constructor() ConfirmedOwner(msg.sender) {}\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/shared/interfaces/IOwnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IOwnable {\n  function owner() external returns (address);\n\n  function transferOwnership(address recipient) external;\n\n  function acceptOwnership() external;\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/shared/interfaces/ITypeAndVersion.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface ITypeAndVersion {\n  function typeAndVersion() external pure returns (string memory);\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/shared/token/ERC20/IBurnMintERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC20} from \"../../../vendor/openzeppelin-solidity/v4.8.3/contracts/token/ERC20/IERC20.sol\";\n\ninterface IBurnMintERC20 is IERC20 {\n  /// @notice Mints new tokens for a given address.\n  /// @param account The address to mint the new tokens to.\n  /// @param amount The number of tokens to be minted.\n  /// @dev this function increases the total supply.\n  function mint(address account, uint256 amount) external;\n\n  /// @notice Burns tokens from the sender.\n  /// @param amount The number of tokens to be burned.\n  /// @dev this function decreases the total supply.\n  function burn(uint256 amount) external;\n\n  /// @notice Burns tokens from a given address..\n  /// @param account The address to burn tokens from.\n  /// @param amount The number of tokens to be burned.\n  /// @dev this function decreases the total supply.\n  function burn(address account, uint256 amount) external;\n\n  /// @notice Burns tokens from a given address..\n  /// @param account The address to burn tokens from.\n  /// @param amount The number of tokens to be burned.\n  /// @dev this function decreases the total supply.\n  function burnFrom(address account, uint256 amount) external;\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/vendor/openzeppelin-solidity/v4.8.3/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n  /**\n   * @dev Returns the name of the token.\n   */\n  function name() external view returns (string memory);\n\n  /**\n   * @dev Returns the symbol of the token.\n   */\n  function symbol() external view returns (string memory);\n\n  /**\n   * @dev Returns the decimals places of the token.\n   */\n  function decimals() external view returns (uint8);\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/vendor/openzeppelin-solidity/v4.8.3/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n  /**\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\n   * another (`to`).\n   *\n   * Note that `value` may be zero.\n   */\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  /**\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n   * a call to {approve}. `value` is the new allowance.\n   */\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n\n  /**\n   * @dev Returns the amount of tokens in existence.\n   */\n  function totalSupply() external view returns (uint256);\n\n  /**\n   * @dev Returns the amount of tokens owned by `account`.\n   */\n  function balanceOf(address account) external view returns (uint256);\n\n  /**\n   * @dev Moves `amount` tokens from the caller's account to `to`.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transfer(address to, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Returns the remaining number of tokens that `spender` will be\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\n   * zero by default.\n   *\n   * This value changes when {approve} or {transferFrom} are called.\n   */\n  function allowance(address owner, address spender) external view returns (uint256);\n\n  /**\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\n   * that someone may use both the old and the new allowance by unfortunate\n   * transaction ordering. One possible solution to mitigate this race\n   * condition is to first reduce the spender's allowance to 0 and set the\n   * desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   *\n   * Emits an {Approval} event.\n   */\n  function approve(address spender, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Moves `amount` tokens from `from` to `to` using the\n   * allowance mechanism. `amount` is then deducted from the caller's\n   * allowance.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/vendor/openzeppelin-solidity/v5.0.2/contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.20;\n\nimport {IAccessControl} from \"./IAccessControl.sol\";\nimport {Context} from \"../utils/Context.sol\";\nimport {ERC165} from \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address account => bool) hasRole;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 role => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        return _roles[role].hasRole[account];\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\n     * is missing `role`.\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n\n        _revokeRole(role, callerConfirmation);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (!hasRole(role, account)) {\n            _roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (hasRole(role, account)) {\n            _roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/vendor/openzeppelin-solidity/v5.0.2/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/IAccessControl.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev The `account` is missing a role.\n     */\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n\n    /**\n     * @dev The caller of a function is not the expected one.\n     *\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\n     */\n    error AccessControlBadConfirmation();\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/vendor/openzeppelin-solidity/v5.0.2/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/vendor/openzeppelin-solidity/v5.0.2/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/vendor/openzeppelin-solidity/v5.0.2/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/vendor/openzeppelin-solidity/v5.0.2/contracts/utils/structs/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes32 value => uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "contracts/bridge/CCIPAdmin.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {IGovernance} from \"../equity/IGovernance.sol\";\nimport {ITokenPool} from \"./ITokenPool.sol\";\nimport {TokenAdminRegistry} from \"@chainlink/contracts-ccip/src/v0.8/ccip/tokenAdminRegistry/TokenAdminRegistry.sol\";\nimport {RateLimiter} from \"@chainlink/contracts-ccip/src/v0.8/ccip/libraries/RateLimiter.sol\";\nimport {IBasicFrankencoin} from \"../stablecoin/IBasicFrankencoin.sol\";\nimport {RegistryModuleOwnerCustom} from \"@chainlink/contracts-ccip/src/v0.8/ccip/tokenAdminRegistry/RegistryModuleOwnerCustom.sol\";\n\n/**\n * Since there is no centralized administrator, a smart contract relying on the decentralized governance process takes over\n * the admin role. This contract contains all functions to configure the CCIP bridge based on the typical Frankencoin\n * governance process.\n * \n * For the token pool to function properly, it must be equipped with minting power and registered as a minting module.\n * \n * For example, any qualified users can at any time adjust the rate limit of the bridge. But the other, less time-critical\n * functions are exercised in two steps, a proposal and a delayed actual execution if no veto has been cast in the meantime.\n */\ncontract CCIPAdmin {\n    struct RemotePoolUpdate {\n        bool add; // true if adding, false if removing\n        uint64 chain;\n        bytes poolAddress;\n    }\n\n    uint64 public constant DAY = 24 * 60 * 60;\n\n    IGovernance public immutable GOVERNANCE;\n    TokenAdminRegistry public immutable TOKEN_ADMIN_REGISTRY;\n    address public immutable ZCHF;\n\n    ITokenPool public tokenPool;\n    mapping(bytes32 hash => uint64 deadline) public proposals;\n\n    error TooEarly(uint64 deadline);\n    error UnknownProposal(bytes32 hash);\n    error ProposalAlreadyMade(bytes32 hash);\n    error AlreadyRegistered();\n    error TokenPoolNotSet();\n\n    event TokenPoolSet(address indexed tokenPool);\n\n    event ProposalMade(bytes32 hash, uint64 deadline);\n    event ProposalDenied(bytes32 hash);\n    event ProposalEnacted(bytes32 hash);\n\n    event RemotePoolUpdateProposed(bytes32 hash, address indexed proposer, RemotePoolUpdate update);\n    event RemoveChainProposed(bytes32 hash, address indexed proposer, uint64 chain);\n    event AddChainProposed(bytes32 hash, address indexed proposer, ITokenPool.ChainUpdate update);\n    event AdminTransferProposed(bytes32 hash, address indexed proposer, address newAdmin);\n\n    event RemotePoolAdded(uint64 indexed chain, bytes indexed poolAddress);\n    event RemotePoolRemoved(uint64 indexed chain, bytes indexed poolAddress);\n    event ChainRemoved(uint64 id);\n    event ChainAdded(ITokenPool.ChainUpdate config);\n    event AdminTransferred(address newAdmin);\n    event RateLimit(uint64 remoteChain, RateLimiter.Config inboundConfigs, RateLimiter.Config outboundConfig);\n\n    modifier onlyQualified(address[] calldata helpers) {\n        GOVERNANCE.checkQualified(msg.sender, helpers);\n        _;\n    }\n\n    modifier tokenPoolSet() {\n        if (address(tokenPool) == address(0)) revert TokenPoolNotSet();\n        _;\n    }\n\n    constructor(TokenAdminRegistry tokenAdminRegistry, IBasicFrankencoin zchf) {\n        GOVERNANCE = zchf.reserve();\n        TOKEN_ADMIN_REGISTRY = tokenAdminRegistry;\n        ZCHF = address(zchf);\n    }\n    \n    /// @notice Registers the token in the CCIP system\n    /// @dev Can only be called while the token admin is not set\n    /// @param registry The registry to register the token with\n    /// @param _tokenPool The token pool to administer\n    /// @param chainsToAdd The chains to add to the token pool\n    function registerToken(RegistryModuleOwnerCustom registry, ITokenPool _tokenPool, ITokenPool.ChainUpdate[] calldata chainsToAdd) external {\n        // This prevents from reregistering the inital ccipAdmin contract after it got superseded by a new version\n        if (TOKEN_ADMIN_REGISTRY.getTokenConfig(ZCHF).administrator != address(0)) {\n            revert AlreadyRegistered();\n        }\n        // registerAdminViaGetCCIPAdmin() calls proposeAdministrator() in the background which prevents the existing admin from being set as pending\n        registry.registerAdminViaGetCCIPAdmin(ZCHF);\n        acceptAdmin(_tokenPool, chainsToAdd);\n    }\n    \n    /// @notice Accepts the admin role transfer on the TokenAdminRegistry and sets the token pool\n    /// @dev Can only be called if this contract is the pending owner for the token.\n    /// @param _tokenPool The token pool to administer\n    /// @param chainsToAdd The chains to add to the token pool\n    function acceptAdmin(ITokenPool _tokenPool, ITokenPool.ChainUpdate[] calldata chainsToAdd) public {\n        // The token pool can only be reset if this contract is a pending admin again. In this case it could be beneficial to reset the token pool\n        TOKEN_ADMIN_REGISTRY.acceptAdminRole(ZCHF);\n        setTokenPool(_tokenPool, chainsToAdd);\n    }\n    \n    /// @notice Proposed a remote pool update\n    /// @dev The contract only stores the hash. So the data has to be passed in during apply again\n    /// @param update  The update proposal\n    /// @param helpers The helpers to get enough votes\n    function proposeRemotePoolUpdate(RemotePoolUpdate memory update, address[] calldata helpers) external {\n        bytes32 hash = keccak256(abi.encode(\"remotePoolUpdate\", update));\n        propose(hash, 7, helpers);\n        emit RemotePoolUpdateProposed(hash, msg.sender, update);\n    }\n    \n    /// @notice Applies the update on the TokenPool\n    /// @dev Requires the token pool to be set\n    /// @param update RemotePoolUpdate information\n    function applyRemotePoolUpdate(RemotePoolUpdate memory update) external tokenPoolSet {\n        enact(keccak256(abi.encode(\"remotePoolUpdate\", update)));\n        if (update.add) {\n            tokenPool.addRemotePool(update.chain, update.poolAddress);\n            emit RemotePoolAdded(update.chain, update.poolAddress);\n        } else {\n            tokenPool.removeRemotePool(update.chain, update.poolAddress);\n            emit RemotePoolRemoved(update.chain, update.poolAddress);\n        }\n    }\n    \n    /// @notice Sets the rate limits for the given chain. Any qualified voter can apply rate limits with immediate effect.\n    ///         Rate limits can only do limited harm, so it is acceptable to be very permissive. At the same time, rate limits are typically\n    ///         applied during emergencies, e.g. when a chain has been hacked. Therefore, it is desirable to ensure that\n    ///         they can be applied quickly.\n    /// @dev Requires the token pool to be set\n    /// @param chain The chain to set the rate limits for\n    /// @param inbound The inbound rate limits\n    /// @param outbound The outbound rate limits\n    /// @param helpers Array of helper addresses for qualification check\n    function applyRateLimit(uint64 chain, RateLimiter.Config calldata inbound, RateLimiter.Config calldata outbound, address[] calldata helpers) external onlyQualified(helpers) tokenPoolSet {\n        tokenPool.setChainRateLimiterConfig(chain, inbound, outbound);\n        emit RateLimit(chain, inbound, outbound);\n    }\n    \n    /// @notice Propose to add or remove remote chains\n    /// @dev The contract only stores the hash. So the data has to be passed in during apply again\n    /// @param chainId The chain to remove\n    /// @param helpers Array of helper addresses for qualification check\n    function proposeRemoveChain(uint64 chainId, address[] calldata helpers) external {\n        bytes32 hash = keccak256(abi.encode(\"removeChain\", chainId));\n        propose(hash, 7, helpers);\n        emit RemoveChainProposed(hash, msg.sender, chainId);\n    }\n    \n    /// @notice Applies the remove chain proposal\n    /// @dev Requires the token pool to be set\n    /// @param chainId The chain to remove\n    function applyRemoveChain(uint64 chainId) external tokenPoolSet {\n        enact(keccak256(abi.encode(\"removeChain\", chainId)));\n        uint64[] memory chainsToRemove = new uint64[](1);\n        chainsToRemove[0] = chainId;\n        ITokenPool.ChainUpdate[] memory chainsToAdd = new ITokenPool.ChainUpdate[](0);\n        tokenPool.applyChainUpdates(chainsToRemove, chainsToAdd);\n        emit ChainRemoved(chainId);\n    }\n    \n    /// @notice Propose to add a remote chains\n    /// @dev The contract only stores the hash. So the data has to be passed in during apply again\n    /// @param config The chain configuration\n    /// @param helpers Array of helper addresses for qualification check\n    function proposeAddChain(ITokenPool.ChainUpdate calldata config, address[] calldata helpers) external {\n        bytes32 hash = keccak256(abi.encode(\"addChain\", config));\n        propose(hash, 7, helpers);\n        emit AddChainProposed(hash, msg.sender, config);\n    }\n    \n    /// @notice Applies the remote chain update\n    /// @dev Requires the token pool to be set\n    /// @param config RemoteChainUpdate information\n    function applyAddChain(ITokenPool.ChainUpdate memory config) external tokenPoolSet {\n        enact(keccak256(abi.encode(\"addChain\", config)));\n        uint64[] memory chainsToRemove = new uint64[](0);\n        ITokenPool.ChainUpdate[] memory chainsToAdd = new ITokenPool.ChainUpdate[](1);\n        chainsToAdd[0] = config;\n        tokenPool.applyChainUpdates(chainsToRemove, chainsToAdd);\n        emit ChainAdded(config);\n    }\n    \n    /// @notice Proposed a new admin for the TokenPool and Admin on the Token registry\n    /// @param newAdmin  The address of the new admin\n    /// @param helpers Array of helper addresses for qualification check\n    function proposeAdminTransfer(address newAdmin, address[] calldata helpers) external {\n        bytes32 hash = keccak256(abi.encode(\"adminTransfer\", newAdmin));\n        propose(hash, 21, helpers);\n        emit AdminTransferProposed(hash, msg.sender, newAdmin);\n    }\n    \n    /// @notice Applies the admin transfer\n    /// @dev Transfers admin on the TokenPool and ownership on the ZCHF token on the TokenAdminRegistry\n    /// @param newAdmin The address of the new admin\n    function applyAdminTransfer(address newAdmin) external {\n        enact(keccak256(abi.encode(\"adminTransfer\", newAdmin)));\n        TOKEN_ADMIN_REGISTRY.transferAdminRole(ZCHF, newAdmin);\n        if (address(tokenPool) != address(0)) tokenPool.transferOwnership(newAdmin);\n        emit AdminTransferred(newAdmin);\n    }\n    \n    /// @notice Denies and removes a pending proposal\n    /// @dev Only qualified voters can deny proposals\n    /// @param hash The hash of the proposal to deny\n    /// @param helpers Array of helper addresses for qualification check\n    function deny(bytes32 hash, address[] calldata helpers) external onlyQualified(helpers) {\n        if (proposals[hash] == 0) revert UnknownProposal(hash);\n        delete proposals[hash];\n        emit ProposalDenied(hash);\n    }\n    \n    /// @notice Enacts a pending proposal\n    /// @param hash The hash of the proposal to enact\n    function enact(bytes32 hash) internal {\n        uint64 deadline = proposals[hash];\n        if (deadline == 0) revert UnknownProposal(hash);\n        if (deadline > block.timestamp) revert TooEarly(deadline);\n        delete proposals[hash];\n        emit ProposalEnacted(hash);\n    }\n    \n    /// @notice Creates a new proposal with a delay period\n    /// @dev Only qualified voters can create proposals\n    /// @param hash The hash of the proposal data\n    /// @param delayInDays Number of days to delay the proposal execution\n    /// @param helpers Array of helper addresses for qualification check\n    function propose(bytes32 hash, uint64 delayInDays, address[] calldata helpers) internal onlyQualified(helpers) {\n        if (proposals[hash] > 0) revert ProposalAlreadyMade(hash);\n        proposals[hash] = uint64(block.timestamp) + delayInDays * DAY;\n        emit ProposalMade(hash, proposals[hash]);\n    }\n    \n    /// @notice Sets the token pool to administer, sets it in the TokenAdminRegistry, accept ownership, and applies the chain updates\n    /// @dev The token pool needs to have this contract as pending owner\n    /// @param _tokenPool The token pool to set\n    /// @param chainsToAdd The chains to add to the token pool\n    function setTokenPool(ITokenPool _tokenPool, ITokenPool.ChainUpdate[] calldata chainsToAdd) internal {\n        TOKEN_ADMIN_REGISTRY.setPool(ZCHF, address(_tokenPool));\n        _tokenPool.acceptOwnership();\n\n        if (chainsToAdd.length > 0) {\n            _tokenPool.applyChainUpdates(new uint64[](0), chainsToAdd);\n        }\n\n        tokenPool = _tokenPool;\n        emit TokenPoolSet(address(_tokenPool));\n    }\n}\n"
    },
    "contracts/bridge/CCIPSender.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {Client} from \"@chainlink/contracts-ccip/src/v0.8/ccip/libraries/Client.sol\";\nimport {IRouterClient} from \"@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IRouterClient.sol\";\nimport {IERC20} from \"../erc20/IERC20.sol\";\n\nabstract contract CCIPSender {\n    IRouterClient public immutable ROUTER;\n    address public immutable LINK;\n\n    error InsufficientFeeTokens(address token, uint256 fee);\n    error InsufficientFeeTokenAllowance(address token, uint256 fee);\n\n    constructor(IRouterClient router, address link) {\n        ROUTER = router;\n        LINK = link;\n    }\n\n    /// @notice Encodes the receiver correctly\n    /// @param target The target address\n    /// @return The encoded receiver\n    function _toReceiver(address target) internal pure returns (bytes memory) {\n        return abi.encode(target);\n    }\n\n    /// @notice Builds the message struct\n    /// @dev Guesses the fee token based on msg.value\n    /// @param receiver The receiver\n    /// @param payload The payload\n    /// @param tokenAmounts The token amounts\n    /// @param extraArgs The extra args such as gas limit and out-of-order execution\n    /// @return The message struct\n    function _constructMessage(bytes memory receiver, bytes memory payload, Client.EVMTokenAmount[] memory tokenAmounts, bytes memory extraArgs) internal view returns (Client.EVM2AnyMessage memory) {\n        return Client.EVM2AnyMessage(receiver, payload, tokenAmounts, _guessFeeToken(), extraArgs);\n    }\n\n    /// @notice Builds the message struct\n    /// @param receiver The receiver\n    /// @param payload The payload\n    /// @param tokenAmounts The token amounts\n    /// @param nativeToken Whether to use native token or LINK\n    /// @param extraArgs The extra args such as gas limit and out-of-order execution\n    /// @return The message struct\n    function _constructMessage(bytes memory receiver, bytes memory payload, Client.EVMTokenAmount[] memory tokenAmounts, bool nativeToken,  bytes memory extraArgs) internal view returns (Client.EVM2AnyMessage memory) {\n        return Client.EVM2AnyMessage(receiver, payload, tokenAmounts, nativeToken ? address(0) : LINK, extraArgs);\n    }\n\n    /// @notice Gets the fee from the router for the given message and chain combination\n    /// @param chain The chain\n    /// @param message The message\n    /// @return The fee\n    function _calculateFee(uint64 chain, Client.EVM2AnyMessage memory message) internal view returns (uint256) {\n        return ROUTER.getFee(chain, message);\n    }\n\n    /// @notice Sends the message to the router and handles fee payment\n    /// @dev External call to msg.sender if fees are paid in native token. This function can lead to a potential reentrancy.\n    /// @param chain The chain\n    /// @param message The message\n    /// @return The message id and fee\n    function _send(uint64 chain, Client.EVM2AnyMessage memory message) internal returns (bytes32, uint256) {\n        uint256 fee = _calculateFee(chain, message);\n        bytes32 messageId;\n        if (message.feeToken != address(0)) {\n            // We trust the feeToken to be not malicious.\n            // ROUTER.getFee() verifies that the feeToken is supported by CCIP and thus vetted.\n            if (IERC20(message.feeToken).balanceOf(msg.sender) < fee) revert InsufficientFeeTokens(message.feeToken, fee);\n            if (IERC20(message.feeToken).allowance(msg.sender, address(this)) < fee) revert InsufficientFeeTokenAllowance(message.feeToken, fee);\n            IERC20(message.feeToken).transferFrom(msg.sender, address(this), fee);\n            IERC20(message.feeToken).approve(address(ROUTER), fee);\n            messageId = ROUTER.ccipSend(chain, message);\n\n            // Send back any leftover fee tokens\n            uint256 leftover = IERC20(message.feeToken).balanceOf(address(this));\n            if (leftover > 0) IERC20(message.feeToken).transfer(msg.sender, leftover);\n        } else {\n            if (msg.value < fee) revert InsufficientFeeTokens(message.feeToken, fee);\n            messageId = ROUTER.ccipSend{value: fee}(chain, message);\n            // return overpaid fee to sender. We don't care about the success of this call.\n            if(msg.value - fee > 0) payable(msg.sender).call{value: msg.value - fee}(\"\");\n        }\n        return (messageId, fee);\n    }\n\n    /// @notice Guesses the fee token based on msg.value\n    /// @return The fee token\n    function _guessFeeToken() internal view returns (address) {\n        return (msg.value > 0) ? address(0) : LINK;\n    }\n}\n"
    },
    "contracts/bridge/ITokenPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {RateLimiter} from \"@chainlink/contracts-ccip/src/v0.8/ccip/libraries/RateLimiter.sol\";\n\ninterface ITokenPool {\n    \n    struct ChainUpdate {\n        uint64 remoteChainSelector; // Remote chain selector\n        bytes[] remotePoolAddresses; // Address of the remote pool, ABI encoded in the case of a remote EVM chain.\n        bytes remoteTokenAddress; // Address of the remote token, ABI encoded in the case of a remote EVM chain.\n        RateLimiter.Config outboundRateLimiterConfig; // Outbound rate limited config, meaning the rate limits for all of the onRamps for the given chain\n        RateLimiter.Config inboundRateLimiterConfig; // Inbound rate limited config, meaning the rate limits for all of the offRamps for the given chain\n    }\n\n    function addRemotePool(uint64 remoteChainSelector, bytes calldata remotePoolAddress) external;\n    function removeRemotePool(uint64 remoteChainSelector, bytes calldata remotePoolAddress) external;\n\n    function setChainRateLimiterConfig(\n        uint64 remoteChainSelectors,\n        RateLimiter.Config calldata outboundConfigs,\n        RateLimiter.Config calldata inboundConfigs\n    ) external;\n    \n    function applyChainUpdates(\n        uint64[] calldata remoteChainSelectorsToRemove,\n        ChainUpdate[] calldata chainsToAdd\n    ) external;\n\n    function acceptOwnership() external;\n    function transferOwnership(address to) external;\n}\n"
    },
    "contracts/deploy/L2Deployer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {BridgedFrankencoin} from \"../stablecoin/BridgedFrankencoin.sol\";\nimport {BridgedGovernance} from \"../equity/BridgedGovernance.sol\";\nimport {CCIPAdmin} from \"../bridge/CCIPAdmin.sol\";\nimport {TokenAdminRegistry} from \"@chainlink/contracts-ccip/src/v0.8/ccip/tokenAdminRegistry/TokenAdminRegistry.sol\";\nimport {BurnMintTokenPool} from \"@chainlink/contracts-ccip/src/v0.8/ccip/pools/BurnMintTokenPool.sol\";\nimport {IBurnMintERC20} from \"@chainlink/contracts-ccip/src/v0.8/shared/token/ERC20/IBurnMintERC20.sol\";\nimport {RegistryModuleOwnerCustom} from \"@chainlink/contracts-ccip/src/v0.8/ccip/tokenAdminRegistry/RegistryModuleOwnerCustom.sol\";\nimport {ITokenPool} from \"../bridge/ITokenPool.sol\";\nimport {L2TestMinter} from \"./L2TestMinter.sol\";\n\ncontract L2Deployer {\n    struct CCIPConfig {\n        address router;\n        uint64 mainnetChainSelector;\n        address linkToken;\n        TokenAdminRegistry tokenAdminRegistry;\n        address rmnProxy;\n        RegistryModuleOwnerCustom registryModuleOwnerCustom;\n        ITokenPool.ChainUpdate[] chainsToAdd;\n    }\n\n    struct FrankencoinConfig {\n        uint256 minApplicationPeriod;\n        address bridgeAccounting;\n        address ccipAdmin;\n    }\n\n    BridgedFrankencoin public bridgedFrankencoin;\n    CCIPAdmin public ccipAdmin;\n    BurnMintTokenPool public tokenPool;\n    L2TestMinter public testMinter;\n\n    error CCIPAdminMismatch(address expected, address actual);\n\n    constructor(CCIPConfig memory _ccipConfig, BridgedGovernance _bridgedGovernance, FrankencoinConfig memory _frankencoinConfig) {\n        // Deployment logic\n        bridgedFrankencoin = new BridgedFrankencoin(\n            _bridgedGovernance,\n            _ccipConfig.router,\n            _frankencoinConfig.minApplicationPeriod,\n            _ccipConfig.linkToken,\n            _ccipConfig.mainnetChainSelector,\n            _frankencoinConfig.bridgeAccounting,\n            _frankencoinConfig.ccipAdmin\n        );\n        ccipAdmin = new CCIPAdmin(_ccipConfig.tokenAdminRegistry, bridgedFrankencoin);\n        if (_frankencoinConfig.ccipAdmin != address(ccipAdmin)) revert CCIPAdminMismatch(address(ccipAdmin), _frankencoinConfig.ccipAdmin);\n\n        address[] memory allowlist = new address[](0);\n        tokenPool = new BurnMintTokenPool(IBurnMintERC20(address(bridgedFrankencoin)), bridgedFrankencoin.decimals(), allowlist, _ccipConfig.rmnProxy, _ccipConfig.router);\n        tokenPool.transferOwnership(address(ccipAdmin));\n\n        testMinter = new L2TestMinter();\n\n        address[] memory minters = new address[](2);\n        minters[0] = address(tokenPool);\n        minters[1] = address(testMinter);\n\n        string[] memory minterComments = new string[](2);\n        minterComments[0] = \"BurnMintTokenPool\";\n        minterComments[1] = \"TestMinter\";\n        bridgedFrankencoin.initialize(minters, minterComments);\n\n        testMinter.mint(bridgedFrankencoin, msg.sender);\n\n        ccipAdmin.registerToken(_ccipConfig.registryModuleOwnerCustom, ITokenPool(address(tokenPool)), _ccipConfig.chainsToAdd);\n    }\n}\n"
    },
    "contracts/deploy/L2TestMinter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IBasicFrankencoin} from \"../stablecoin/IBasicFrankencoin.sol\";\n\n\ncontract L2TestMinter {\n    bool public used;\n\n    constructor() {\n\n    }\n\n    function mint(IBasicFrankencoin token, address target) external {\n        require(!used, \"Used\");\n        token.mint(target, 1 ether);\n        used = true;\n    }\n}"
    },
    "contracts/equity/BridgedGovernance.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {CCIPReceiver} from \"@chainlink/contracts-ccip/src/v0.8/ccip/applications/CCIPReceiver.sol\";\nimport {Client} from \"@chainlink/contracts-ccip/src/v0.8/ccip/libraries/Client.sol\";\nimport {SyncVote, SyncMessage} from \"./IGovernance.sol\";\nimport {Governance} from \"./Governance.sol\";\n\n/**\n * This contract receives messages from the mainnet governance contract about the voting power of individual addresses\n * as well as the total number of votes at the time of synchronization, and to whom they are delegating (if anyone).\n * \n * Accounts that alone or with the help of delegations reach 2% of the votes gain veto power and are considered 'qualified'.\n * See also the 'checkQualified' method in the parent class and the IGovernance interface. The governance process is not\n * done through majority votes, but by exercising veto power. Generally, anyone can make governance proposals that pass\n * automatically after a grace period unless a qualified user vetoes the proposal, leading to a very light-weight and\n * decentralized governance process.\n * \n * As the total number of votes increases with time (votes is the holding duration times the number of governance tokens\n * held), the voting power of previously synchronized accounts tends to decrease with subsequent new synchronizations,\n * leading to a natural and desired decay. Delegations can either be synchronized from mainnet or done locally on\n * the current chain (with the risk of being overwritten when someone triggers a sync for the delegating account).\n */\ncontract BridgedGovernance is CCIPReceiver, Governance {\n\n    uint64 public immutable MAINNET_CHAIN_SELECTOR;\n    address public immutable MAINNET_GOVERNANCE_ADDRESS;\n\n    mapping(address => uint256) private _votes;\n    uint256 private _totalVotes;\n\n    event MessageReceived(bytes32 messageId, uint64 sourceChain, uint256 totalVotes, SyncVote[] syncedVotes);\n\n    error InvalidSourceChain();\n    error InvalidSender();\n\n    constructor(address router, uint64 mainnetChainSelector, address mainnetGovernanceAddress) CCIPReceiver(router) {\n        MAINNET_CHAIN_SELECTOR = mainnetChainSelector;\n        MAINNET_GOVERNANCE_ADDRESS = mainnetGovernanceAddress;\n    }\n\n    /// @notice Get the number of votes held by a holder.\n    /// @param holder The address to check.\n    function votes(address holder) public view override returns (uint256) {\n        return _votes[holder];\n    }\n\n    /// @notice Get the total number of votes.\n    function totalVotes() public view override returns (uint256) {\n        return _totalVotes;\n    }\n\n    /// @notice Process a sync message.\n    /// @param any2EvmMessage The message to process.\n    function _ccipReceive(Client.Any2EVMMessage memory any2EvmMessage) internal override {\n        if (any2EvmMessage.sourceChainSelector != MAINNET_CHAIN_SELECTOR) revert InvalidSourceChain();\n        if (abi.decode(any2EvmMessage.sender, (address)) != MAINNET_GOVERNANCE_ADDRESS) revert InvalidSender();\n\n        SyncMessage memory syncMessage = abi.decode(any2EvmMessage.data, (SyncMessage)); // abi-decoding of the sent text\n\n        _processSyncMessage(syncMessage);\n\n        emit MessageReceived(any2EvmMessage.messageId, any2EvmMessage.sourceChainSelector, syncMessage.totalVotes, syncMessage.votes);\n    }\n\n    /// @notice Updates internal state with received message\n    /// @param syncMessage The message to process.\n    function _processSyncMessage(SyncMessage memory syncMessage) internal {\n        _totalVotes = syncMessage.totalVotes;\n\n        // omitted unchecked optimization for readability\n        for (uint64 i = 0; i < syncMessage.votes.length; i++) {\n            SyncVote memory syncVote = syncMessage.votes[i];\n            _votes[syncVote.voter] = syncVote.votes;\n            delegate(syncVote.voter, syncVote.delegatee);\n        }\n    }\n}\n"
    },
    "contracts/equity/Equity.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./Governance.sol\";\nimport \"../stablecoin/Frankencoin.sol\";\nimport \"../utils/MathUtil.sol\";\nimport \"../erc20/IERC677Receiver.sol\";\n\n/**\n * @title Equity\n * @notice If the Frankencoin system was a bank, this contract would represent the equity on its balance sheet.\n * Like with a corporation, the owners of the equity capital are the shareholders, or in this case the holders\n * of Frankencoin Pool Shares (FPS) tokens. Anyone can mint additional FPS tokens by adding Frankencoins to the\n * reserve pool. Also, FPS tokens can be redeemed for Frankencoins again after a minimum holding period.\n * Furthermore, the FPS shares come with some voting power. Anyone that held at least 3% of the holding-period-\n * weighted reserve pool shares gains veto power and can veto new proposals.\n */\ncontract Equity is Governance, ERC20PermitLight, MathUtil {\n    /**\n     * The VALUATION_FACTOR determines the market cap of the reserve pool shares relative to the equity reserves.\n     * The following always holds: Market Cap = Valuation Factor * Equity Reserve = Price * Supply\n     *\n     * In the absence of profits and losses, the variables grow as follows when FPS tokens are minted:\n     *\n     * |   Reserve     |   Market Cap  |     Price     |     Supply   |\n     * |          1000 |          3000 |             3 |         1000 |\n     * |       1000000 |       3000000 |           300 |        10000 |\n     * |    1000000000 |    3000000000 |         30000 |       100000 |\n     * | 1000000000000 | 3000000000000 |       3000000 |      1000000 |\n     *\n     * I.e., the supply is proporational to the cubic root of the reserve and the price is proportional to the\n     * squared cubic root. When profits accumulate or losses materialize, the reserve, the market cap,\n     * and the price are adjusted proportionally, with the supply staying constant. In the absence of an extreme\n     * inflation of the Swiss franc, it is unlikely that there will ever be more than ten million FPS.\n     */\n    uint32 public constant VALUATION_FACTOR = 3;\n\n    uint256 private constant MINIMUM_EQUITY = 1000 * ONE_DEC18;\n\n    /**\n     * @notice The number of digits to store the average holding time of share tokens.\n     */\n    uint8 private constant TIME_RESOLUTION_BITS = 20;\n\n    /**\n     * @notice The minimum holding duration. You are not allowed to redeem your pool shares if you held them\n     * for less than the minimum holding duration at average. For example, if you have two pool shares on your\n     * address, one acquired 5 days ago and one acquired 105 days ago, you cannot redeem them as the average\n     * holding duration of your shares is only 55 days < 90 days.\n     */\n    uint256 public constant MIN_HOLDING_DURATION = 90 days << TIME_RESOLUTION_BITS; // Set to 5 for local testing\n\n    Frankencoin public immutable zchf;\n\n    /**\n     * @dev To track the total number of votes we need to know the number of votes at the anchor time and when the\n     * anchor time was. This is (hopefully) stored in one 256 bit slot, with the anchor time taking 64 Bits and\n     * the total vote count 192 Bits. Given the sub-second resolution of 20 Bits, the implicit assumption is\n     * that the timestamp can always be stored in 44 Bits (i.e. it does not exceed half a million years). Further,\n     * given 18 decimals (about 60 Bits), this implies that the total supply cannot exceed\n     *   192 - 60 - 44 - 20 = 68 Bits\n     * Here, we are also save, as 68 Bits would imply more than a trillion outstanding shares. In fact,\n     * a limit of about 2**36 shares (that's about 2**96 Bits when taking into account the decimals) is imposed\n     * when minting. This means that the maximum supply is billions shares, which is could only be reached in\n     * a scenario with hyper inflation, in which case the stablecoin is worthless anyway.\n     */\n    uint192 private totalVotesAtAnchor; // Total number of votes at the anchor time, see comment on the um\n    uint64 private totalVotesAnchorTime; // 44 Bit for the time stamp, 20 Bit sub-second time resolution\n\n    /**\n     * @notice A time stamp in the past such that: votes = balance * (time passed since anchor was set)\n     */\n    mapping(address owner => uint64 timestamp) private voteAnchor; // 44 bits for time stamp, 20 subsecond resolution\n\n    event Trade(address who, int amount, uint totPrice, uint newprice); // amount pos or neg for mint or redemption\n\n    constructor(Frankencoin zchf_) ERC20(18) {\n        zchf = zchf_;\n    }\n\n    function name() external pure override returns (string memory) {\n        return \"Frankencoin Pool Share\";\n    }\n\n    function symbol() external pure override returns (string memory) {\n        return \"FPS\";\n    }\n\n    /**\n     * @notice Returns the price of one FPS in ZCHF with 18 decimals precision.\n     */\n    function price() public view returns (uint256) {\n        uint256 equity = zchf.equity();\n        if (equity == 0 || totalSupply() == 0) {\n            return ONE_DEC18; // initial price is 1000 ZCHF for the first 1000 FPS\n        } else {\n            return (VALUATION_FACTOR * zchf.equity() * ONE_DEC18) / totalSupply();\n        }\n    }\n\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal override {\n        super._beforeTokenTransfer(from, to, amount);\n        if (amount > 0) {\n            // No need to adjust the sender votes. When they send out 10% of their shares, they also lose 10% of\n            // their votes so everything falls nicely into place. Recipient votes should stay the same, but grow\n            // faster in the future, requiring an adjustment of the anchor.\n            uint256 roundingLoss = _adjustRecipientVoteAnchor(to, amount);\n            // The total also must be adjusted and kept accurate by taking into account the rounding error.\n            _adjustTotalVotes(from, amount, roundingLoss);\n        }\n    }\n\n    /**\n     * @notice Returns whether the given address is allowed to redeem FPS, which is the\n     * case after their average holding duration is larger than the required minimum.\n     */\n    function canRedeem(address owner) public view returns (bool) {\n        return _anchorTime() - voteAnchor[owner] >= MIN_HOLDING_DURATION;\n    }\n\n    /**\n     * @notice Decrease the total votes anchor when tokens lose their voting power due to being moved\n     * @param from      sender\n     * @param amount    amount to be sent\n     */\n    function _adjustTotalVotes(address from, uint256 amount, uint256 roundingLoss) internal {\n        uint64 time = _anchorTime();\n        uint256 lostVotes = from == address(0x0) ? 0 : (time - voteAnchor[from]) * amount;\n        totalVotesAtAnchor = uint192(totalVotes() - roundingLoss - lostVotes);\n        totalVotesAnchorTime = time;\n    }\n\n    /**\n     * @notice the vote anchor of the recipient is moved forward such that the number of calculated\n     * votes does not change despite the higher balance.\n     * @param to        receiver address\n     * @param amount    amount to be received\n     * @return the number of votes lost due to rounding errors\n     */\n    function _adjustRecipientVoteAnchor(address to, uint256 amount) internal returns (uint256) {\n        if (to != address(0x0)) {\n            uint256 recipientVotes = votes(to); // for example 21 if 7 shares were held for 3 seconds\n            uint256 newbalance = balanceOf(to) + amount; // for example 11 if 4 shares are added\n            // new example anchor is only 21 / 11 = 1 second in the past\n            voteAnchor[to] = uint64(_anchorTime() - recipientVotes / newbalance);\n            return recipientVotes % newbalance; // we have lost 21 % 11 = 10 votes\n        } else {\n            // optimization for burn, vote anchor of null address does not matter\n            return 0;\n        }\n    }\n\n    /**\n     * @notice Time stamp with some additional bits for higher resolution.\n     */\n    function _anchorTime() internal view returns (uint64) {\n        return uint64(block.timestamp << TIME_RESOLUTION_BITS);\n    }\n\n    /**\n     * @notice The relative voting power of the address.\n     * @return A percentage with 1e18 being 100%\n     */\n    function relativeVotes(address holder) external view returns (uint256) {\n        return (ONE_DEC18 * votes(holder)) / totalVotes();\n    }\n\n    /**\n     * @notice The votes of the holder, excluding votes from delegates.\n     */\n    function votes(address holder) public override view returns (uint256) {\n        return balanceOf(holder) * (_anchorTime() - voteAnchor[holder]);\n    }\n\n    /**\n     * @notice How long the holder already held onto their average FPS in seconds.\n     */\n    function holdingDuration(address holder) public view returns (uint256) {\n        return (_anchorTime() - voteAnchor[holder]) >> TIME_RESOLUTION_BITS;\n    }\n\n    /**\n     * @notice Total number of votes in the system.\n     */\n    function totalVotes() public override view returns (uint256) {\n        return totalVotesAtAnchor + totalSupply() * (_anchorTime() - totalVotesAnchorTime);\n    }\n\n    /**\n     * @notice Since quorum is rather low, it is important to have a way to prevent malicious minority holders\n     * from blocking the whole system. This method provides a way for the good guys to team up and destroy\n     * the bad guy's votes (at the cost of also reducing their own votes). This mechanism potentially\n     * gives full control over the system to whoever has 51% of the votes.\n     *\n     * Since this is a rather aggressive measure, delegation is not supported. Every holder must call this\n     * method on their own.\n     * @param targets   The target addresses to remove votes from\n     * @param votesToDestroy    The maximum number of votes the caller is willing to sacrifice\n     */\n    function kamikaze(address[] calldata targets, uint256 votesToDestroy) external {\n        uint256 budget = _reduceVotes(msg.sender, votesToDestroy);\n        uint256 destroyedVotes = 0;\n        for (uint256 i = 0; i < targets.length && destroyedVotes < budget; i++) {\n            destroyedVotes += _reduceVotes(targets[i], budget - destroyedVotes);\n        }\n        require(destroyedVotes > 0); // sanity check\n        totalVotesAtAnchor = uint192(totalVotes() - destroyedVotes - budget);\n        totalVotesAnchorTime = _anchorTime();\n    }\n\n    function _reduceVotes(address target, uint256 amount) internal returns (uint256) {\n        uint256 votesBefore = votes(target);\n        if (amount >= votesBefore) {\n            voteAnchor[target] = _anchorTime();\n            return votesBefore;\n        } else {\n            voteAnchor[target] = uint64(_anchorTime() - (votesBefore - amount) / balanceOf(target));\n            return votesBefore - votes(target);\n        }\n    }\n\n    /**\n     * @notice Call this method to obtain newly minted pool shares in exchange for Frankencoins.\n     * No allowance required (i.e. it is hardcoded in the Frankencoin token contract).\n     * Make sure to invest at least 10e-12 * market cap to avoid rounding losses.\n     *\n     * @dev If equity is close to zero or negative, you need to send enough ZCHF to bring equity back to 1000 ZCHF.\n     *\n     * @param amount            Frankencoins to invest\n     * @param expectedShares    Minimum amount of expected shares for frontrunning protection\n     */\n    function invest(uint256 amount, uint256 expectedShares) external returns (uint256) {\n        zchf.transferFrom(msg.sender, address(this), amount);\n        uint256 equity = zchf.equity();\n        require(equity >= MINIMUM_EQUITY, \"insuf equity\"); // ensures that the initial deposit is at least 1000 ZCHF\n\n        uint256 shares = _calculateShares(equity <= amount ? 0 : equity - amount, amount);\n        require(shares >= expectedShares);\n        _mint(msg.sender, shares);\n        emit Trade(msg.sender, int(shares), amount, price());\n\n        // limit the total supply to a reasonable amount to guard against overflows with price and vote calculations\n        // the 36 bits are 68 bits for magnitude and 60 bits for precision, as calculated in an above comment\n        require(totalSupply() <= type(uint96).max, \"total supply exceeded\");\n        return shares;\n    }\n\n    /**\n     * @notice Calculate shares received when investing Frankencoins\n     * @param investment    ZCHF to be invested\n     * @return shares to be received in return\n     */\n    function calculateShares(uint256 investment) external view returns (uint256) {\n        return _calculateShares(zchf.equity(), investment);\n    }\n\n    function _calculateShares(uint256 capitalBefore, uint256 investment) internal view returns (uint256) {\n        uint256 totalShares = totalSupply();\n        uint256 investmentExFees = (investment * 997) / 1000; // remove 0.3% fee\n        // Assign 1000 FPS for the initial deposit, calculate the amount otherwise\n        uint256 newTotalShares = capitalBefore < MINIMUM_EQUITY || totalShares == 0\n            ? totalShares + 1000 * ONE_DEC18\n            : _mulD18(totalShares, _cubicRoot(_divD18(capitalBefore + investmentExFees, capitalBefore)));\n        return newTotalShares - totalShares;\n    }\n\n    /**\n     * @notice Redeem the given amount of shares owned by the sender and transfer the proceeds to the target.\n     * @return The amount of ZCHF transferred to the target\n     */\n    function redeem(address target, uint256 shares) external returns (uint256) {\n        return _redeemFrom(msg.sender, target, shares);\n    }\n\n    /**\n     * @notice Like redeem(...), but with an extra parameter to protect against frontrunning.\n     * @param expectedProceeds  The minimum acceptable redemption proceeds.\n     */\n    function redeemExpected(address target, uint256 shares, uint256 expectedProceeds) external returns (uint256) {\n        uint256 proceeds = _redeemFrom(msg.sender, target, shares);\n        require(proceeds >= expectedProceeds);\n        return proceeds;\n    }\n\n    /**\n     * @notice Redeem FPS based on an allowance from the owner to the caller.\n     * See also redeemExpected(...).\n     */\n    function redeemFrom(\n        address owner,\n        address target,\n        uint256 shares,\n        uint256 expectedProceeds\n    ) external returns (uint256) {\n        _useAllowance(owner, msg.sender, shares);\n        uint256 proceeds = _redeemFrom(owner, target, shares);\n        require(proceeds >= expectedProceeds);\n        return proceeds;\n    }\n\n    function _redeemFrom(address owner, address target, uint256 shares) internal returns (uint256) {\n        require(canRedeem(owner));\n        uint256 proceeds = calculateProceeds(shares);\n        _burn(owner, shares);\n        zchf.transfer(target, proceeds);\n        emit Trade(owner, -int(shares), proceeds, price());\n        return proceeds;\n    }\n\n    /**\n     * @notice Calculate ZCHF received when depositing shares\n     * @param shares number of shares we want to exchange for ZCHF,\n     *               in dec18 format\n     * @return amount of ZCHF received for the shares\n     */\n    function calculateProceeds(uint256 shares) public view returns (uint256) {\n        uint256 totalShares = totalSupply();\n        require(shares + ONE_DEC18 < totalShares, \"too many shares\"); // make sure there is always at least one share\n        uint256 capital = zchf.equity();\n        uint256 reductionAfterFees = (shares * 997) / 1000;\n        uint256 newCapital = _mulD18(capital, _power3(_divD18(totalShares - reductionAfterFees, totalShares)));\n        return capital - newCapital;\n    }\n\n    /**\n     * @notice If there is less than 1000 ZCHF in equity left (maybe even negative), the system is at risk\n     * and we should allow qualified FPS holders to restructure the system.\n     *\n     * Example: there was a devastating loss and equity stands at -1'000'000. Most shareholders have lost hope in the\n     * Frankencoin system except for a group of small FPS holders who still believes in it and is willing to provide\n     * 2'000'000 ZCHF to save it. These brave souls are essentially donating 1'000'000 to the minter reserve and it\n     * would be wrong to force them to share the other million with the passive FPS holders. Instead, they will get\n     * the possibility to bootstrap the system again owning 100% of all FPS shares.\n     *\n     * @param helpers          A list of addresses that delegate to the caller in incremental order\n     * @param addressesToWipe  A list of addresses whose FPS will be burned to zero\n     */\n    function restructureCapTable(address[] calldata helpers, address[] calldata addressesToWipe) external {\n        require(zchf.equity() < MINIMUM_EQUITY);\n        checkQualified(msg.sender, helpers);\n        for (uint256 i = 0; i < addressesToWipe.length; i++) {\n            address current = addressesToWipe[i];\n            _burn(current, balanceOf(current));\n        }\n    }\n}\n"
    },
    "contracts/equity/FPSWrapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../erc20/ERC20.sol\";\nimport \"../erc20/ERC20PermitLight.sol\";\nimport \"./Equity.sol\";\n\ncontract FPSWrapper is ERC20 {\n\n    Equity private immutable fps;\n\n    constructor(Equity fps_) ERC20(18){\n        fps = fps_;\n    }\n\n    function name() external pure override returns (string memory) {\n        return \"Wrapped Frankencoin Pool Share\";\n    }\n\n    function symbol() external pure override returns (string memory) {\n        return \"WFPS\";\n    }\n\n    // requires allowance\n    function wrap(uint256 amount) public {\n        depositFor(msg.sender, amount);\n    }\n\n    /**\n     * Same function as in openzeppelin ERC20Wrapper\n     * @dev Allow a user to deposit underlying tokens and mint the corresponding number of wrapped tokens.\n     */\n    function depositFor(address account, uint256 amount) public virtual returns (bool) {\n        fps.transferFrom(msg.sender, address(this), amount);\n        super._mint(account, amount);\n        return true;\n    }\n\n    function unwrap(uint256 amount) public {\n        withdrawTo(msg.sender, amount);\n    }\n\n    /**\n     * Same function as in openzeppelin ERC20Wrapper\n     * @dev Allow a user to burn a number of wrapped tokens and withdraw the corresponding number of underlying tokens.\n     */\n    function withdrawTo(address account, uint256 amount) public virtual returns (bool) {\n        super._burn(msg.sender, amount);\n        fps.transfer(account, amount);\n        return true;\n    }\n\n    /**\n     * @dev Returns the address of the underlying ERC-20 token that is being wrapped.\n     */\n    function underlying() public view returns (IERC20) {\n        return fps;\n    }\n\n    /**\n     * Sell immediately, bypassing the 90 day holding requirement if the\n     * average wrapped token has been around for long enough and no one\n     * cancelled the votes of this contract. Can help with market making\n     * between chains when this token is bridged.\n     * \n     * Anyone can prevent this method from being executable via the\n     * halveHoldingDuration function. Also, it won't be executable in an\n     * expanding market where the number of wrapped FPS doubles every\n     * 90 days such that the average holding period of this contract stays\n     * below that duration.\n     */\n    function unwrapAndSell(uint256 amount) public {\n        super._burn(msg.sender, amount);\n        fps.redeem(msg.sender, amount);\n    }\n\n    /**\n     * Reduces the recorded holding duration of the wrapped FPS. This has two effects:\n     * - Averts the risk of this contract accumulating too many votes over time (i.e. 98%)\n     * - Can prevent \"unwrapAndSell\" from succeeding (which can be desired to prevent short\n     *   term arbitrage at the cost of all other FPS holders)\n     * \n     * Anyone with 2% of the votes can call this.\n     */\n    function halveHoldingDuration(address[] calldata helpers) public {\n        fps.checkQualified(msg.sender, helpers);\n        // causes our votes to be cut in half\n        fps.transfer(address(this), totalSupply());\n    }\n\n}"
    },
    "contracts/equity/Governance.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IGovernance.sol\";\n\n/**\n * Contract to consult when checking if someone has veto power.\n * Veto power is reached with 2% of the votes.\n */\nabstract contract Governance is IGovernance {\n\n    /**\n     * @notice The quorum in basis points. 100 is 1%.\n     */\n    uint32 private constant QUORUM = 200;\n\n    /**\n     * @notice Keeping track on who delegated votes to whom.\n     * Note that delegation does not mean you cannot vote / veto any more, it just means that the delegate can\n     * benefit from your votes when invoking a veto. Circular delegations are valid, do not help when voting.\n     */\n    mapping(address owner => address delegate) public delegates;\n\n    event Delegation(address indexed from, address indexed to); // indicates a delegation\n\n    /**\n     * @notice The votes of the holder, excluding votes from delegates.\n     */\n    function votes(address holder) virtual public view returns (uint256);\n\n    /**\n     * @notice Total number of votes in the system.\n     */\n    function totalVotes() virtual public view returns (uint256);\n\n    /**\n     * @notice The number of votes the sender commands when taking the support of the helpers into account.\n     * @param sender    The address whose total voting power is of interest\n     * @param helpers   An incrementally sorted list of helpers without duplicates and without the sender.\n     *                  The call fails if the list contains an address that does not delegate to sender.\n     *                  For indirect delegates, i.e. a -> b -> c, both a and b must be included for both to count.\n     * @return          The total number of votes of sender at the current point in time.\n     */\n    function votesDelegated(address sender, address[] calldata helpers) public view returns (uint256) {\n        uint256 _votes = votes(sender);\n        require(_checkDuplicatesAndSorted(helpers));\n        for (uint i = 0; i < helpers.length; i++) {\n            address current = helpers[i];\n            require(current != sender);\n            require(_canVoteFor(sender, current));\n            _votes += votes(current);\n        }\n        return _votes;\n    }\n\n    function _checkDuplicatesAndSorted(address[] calldata helpers) internal pure returns (bool ok) {\n        if (helpers.length <= 1) {\n            return true;\n        } else {\n            address prevAddress = helpers[0];\n            for (uint i = 1; i < helpers.length; i++) {\n                if (helpers[i] <= prevAddress) {\n                    return false;\n                }\n                prevAddress = helpers[i];\n            }\n            return true;\n        }\n    }\n\n    /**\n     * @notice Checks whether the sender address is qualified given a list of helpers that delegated their votes\n     * directly or indirectly to the sender. It is the responsiblity of the caller to figure out whether\n     * helps are necessary and to identify them by scanning the blockchain for Delegation events.\n     */\n    function checkQualified(address sender, address[] calldata helpers) public view override {\n        uint256 _votes = votesDelegated(sender, helpers);\n        if (_votes * 10000 < QUORUM * totalVotes()) revert NotQualified();\n    }\n\n    error NotQualified();\n\n    /**\n     * @notice Increases the voting power of the delegate by your number of votes without taking away any voting power\n     * from the sender.\n     */\n    function delegateVoteTo(address delegate_) external {\n        delegate(msg.sender, delegate_);\n    }\n\n    function delegate(address owner, address delegate_) internal {\n        delegates[owner] = delegate_;\n        emit Delegation(owner, delegate_);\n    }\n\n    function _canVoteFor(address delegate_, address owner) internal view returns (bool) {\n        if (owner == delegate_) {\n            return true;\n        } else if (owner == address(0x0)) {\n            return false;\n        } else {\n            return _canVoteFor(delegate_, delegates[owner]);\n        }\n    }\n\n}"
    },
    "contracts/equity/GovernanceSender.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {Client} from \"@chainlink/contracts-ccip/src/v0.8/ccip/libraries/Client.sol\";\nimport {SyncVote, SyncMessage} from \"./IGovernance.sol\";\nimport {Governance} from \"./Governance.sol\";\nimport {IRouterClient} from \"@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IRouterClient.sol\";\nimport {IERC20} from \"../erc20/IERC20.sol\";\nimport {CCIPSender} from \"../bridge/CCIPSender.sol\";\n\ncontract GovernanceSender is CCIPSender {\n    Governance public immutable GOVERNANCE;\n\n    event VotesSynced(\n        uint64 indexed chain, // The chain selector of the destination chain.\n        bytes receiver,\n        address[] syncedVoters\n    );\n\n    constructor(Governance _governance, IRouterClient _router, address _linkToken) CCIPSender(_router, _linkToken) {\n        GOVERNANCE = _governance;\n    }\n\n    /// @notice Sync governance votes to destination\n    /// @param chain The chain selector of the destination chain.\n    /// @param receiver The address of the recipient on the destination chain.\n    /// @param voters The voters to sync.\n    function pushVotes(uint64 chain, address receiver, address[] calldata voters) external payable {\n        pushVotes(chain, _toReceiver(receiver), voters, \"\");\n    }\n\n    /// @notice Sync governance votes to destination\n    /// @param chain The chain selector of the destination chain.\n    /// @param receiver The address of the recipient on the destination chain.\n    /// @param voters The voters to sync.\n    /// @param extraArgs Extra arguments for CCIP\n    function pushVotes(uint64 chain, address receiver, address[] calldata voters, Client.EVMExtraArgsV2 calldata extraArgs) public payable {\n        pushVotes(chain, _toReceiver(receiver), voters, Client._argsToBytes(extraArgs));\n    }\n\n    /// @notice Sync governance votes to destination paying with native token\n    /// @dev extraArgs for CCIP can be provided such as gasLimit or out-of-order execution\n    /// @param receiver Address of the recipient on the destination chain\n    /// @param chain Chain selector of the destination chain\n    /// @param voters Collection of addresses which votes and delegation should be synced\n    /// @param extraArgs Extra arguments for CCIP\n    function pushVotes(uint64 chain, bytes memory receiver, address[] calldata voters, bytes memory extraArgs) public payable {\n        SyncMessage memory syncMessage = _buildSyncMessage(voters);\n        Client.EVM2AnyMessage memory message = _constructMessage(receiver, abi.encode(syncMessage), new Client.EVMTokenAmount[](0), extraArgs);\n        _send(chain, message);\n        emit VotesSynced(chain, receiver, voters);\n    }\n\n    /// @notice Returns the fee required to send the sync message.\n    /// @param chain The selector of the destination chain.\n    /// @param receiver The address of the recipient on the destination chain.\n    /// @param voters The voters to sync.\n    /// @param useNativeToken Whether to use native token or LINK\n    /// @return The fee required to send the sync message.\n    function getCCIPFee(uint64 chain, address receiver, address[] calldata voters, bool useNativeToken) external view returns (uint256) {\n        return getCCIPFee(chain, _toReceiver(receiver), voters, useNativeToken, \"\");\n    }\n\n    /// @notice Returns the fee required to send the sync message.\n    /// @param chain The selector of the destination chain.\n    /// @param receiver The address of the recipient on the destination chain.\n    /// @param voters The voters to sync.\n    /// @param useNativeToken Whether to use native token or LINK\n    /// @param extraArgs Extra arguments for CCIP\n    /// @return The fee required to send the sync message.\n    function getCCIPFee(uint64 chain, address receiver, address[] calldata voters, bool useNativeToken, Client.EVMExtraArgsV2 calldata extraArgs) external view returns (uint256) {\n        return getCCIPFee(chain, _toReceiver(receiver), voters, useNativeToken, Client._argsToBytes(extraArgs));\n    }\n\n    /// @notice Returns the fee required to send the sync message.\n    /// @param chain The selector of the destination chain.\n    /// @param receiver The address of the recipient on the destination chain.\n    /// @param voters The voters to sync.\n    /// @param nativeToken Whether to use native token or LINK\n    /// @param extraArgs Extra arguments for CCIP\n    /// @return The fee required to send the sync message.\n    function getCCIPFee(uint64 chain, bytes memory receiver, address[] calldata voters, bool nativeToken, bytes memory extraArgs) public view returns (uint256) {\n        SyncMessage memory syncMessage = _buildSyncMessage(voters);\n        Client.EVM2AnyMessage memory message = _constructMessage(receiver, abi.encode(syncMessage), new Client.EVMTokenAmount[](0), nativeToken, extraArgs);\n        return _calculateFee(chain, message);\n    }\n\n    /// @notice Returns the sync message.\n    /// @param voters The voters to sync.\n    /// @return The sync message.\n    function _buildSyncMessage(address[] calldata voters) private view returns (SyncMessage memory) {\n        SyncVote[] memory _pushVotes = new SyncVote[](voters.length);\n\n        // omitted unchecked optimization for readability\n        for (uint256 i = 0; i < voters.length; i++) {\n            _pushVotes[i] = SyncVote(voters[i], GOVERNANCE.votes(voters[i]), GOVERNANCE.delegates(voters[i]));\n        }\n\n        return SyncMessage(_pushVotes, GOVERNANCE.totalVotes());\n    }\n}\n"
    },
    "contracts/equity/IGovernance.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IGovernance {\n   function checkQualified(address sender, address[] calldata helpers) external view;\n}\n\nstruct SyncVote {\n    address voter;\n    uint256 votes;\n    address delegatee;\n}\n\nstruct SyncMessage {\n    SyncVote[] votes;\n    uint256 totalVotes;\n}\n"
    },
    "contracts/erc20/CrossChainERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Copied from https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol\n// and modified it.\n\npragma solidity ^0.8.0;\n\nimport {ERC20} from \"./ERC20.sol\";\nimport {IRouterClient} from \"@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IRouterClient.sol\";\nimport {Client} from \"@chainlink/contracts-ccip/src/v0.8/ccip/libraries/Client.sol\";\nimport {CCIPSender} from \"../bridge/CCIPSender.sol\";\n\nabstract contract CrossChainERC20 is ERC20, CCIPSender {\n    event Transfer(address indexed from, uint64 toChain, bytes indexed to, uint256 value);\n\n    constructor(address router, address linkToken) CCIPSender(IRouterClient(router), linkToken) {}\n\n    /// @notice Transfers tokens to the target chain\n    /// @dev Requires the caller to approve this contract to spend fee tokens if the CCIP fee is not paid in the chain native token.\n    /// @param targetChain The chain selector of the destination chain.\n    /// @param target The address of the recipient on the destination chain.\n    /// @param amount The amount of tokens to transfer.\n    function transfer(uint64 targetChain, address target, uint256 amount) external payable {\n        transfer(targetChain, _toReceiver(target), amount, \"\");\n    }\n\n    /// @notice Transfers tokens to the target chain\n    /// @dev Requires the caller to approve this contract to spend fee tokens if the CCIP fee is not paid in the chain native token.\n    /// @param targetChain The chain selector of the destination chain.\n    /// @param target The address of the recipient on the destination chain.\n    /// @param amount The amount of tokens to transfer.\n    /// @param extraArgs Extra arguments for CCIP\n    function transfer(uint64 targetChain, address target, uint256 amount, Client.EVMExtraArgsV2 calldata extraArgs) external payable {\n        transfer(targetChain, _toReceiver(target), amount, Client._argsToBytes(extraArgs));\n    }\n\n    /// @notice Transfers tokens to the target chain\n    /// @dev Requires the caller to approve this contract to spend fee tokens if the CCIP fee is not paid in the chain native token.\n    /// @param targetChain The chain selector of the destination chain.\n    /// @param target The address of the recipient on the destination chain.\n    /// @param amount The amount of tokens to transfer.\n    /// @param extraArgs Extra arguments for CCIP\n    function transfer(uint64 targetChain, bytes memory target, uint256 amount, bytes memory extraArgs) public payable {\n        _transfer(msg.sender, address(this), amount);\n        _approve(address(this), address(ROUTER), amount);\n        _send(targetChain, constructTransferMessage(target, amount, extraArgs));\n        emit Transfer(msg.sender, targetChain, target, amount);\n    }\n\n    /// @notice Gets the CCIP fee for a transfer.\n    /// @param targetChain The chain selector of the destination chain.\n    /// @param target The address of the recipient on the destination chain.\n    /// @param amount The amount of tokens to transfer.\n    /// @param nativeToken Whether the token is a native token.\n    function getCCIPFee(uint64 targetChain, address target, uint256 amount, bool nativeToken) public view returns (uint256) {\n        return getCCIPFee(targetChain, _toReceiver(target), amount, nativeToken, \"\");\n    }\n\n    /// @notice Gets the CCIP fee for a transfer.\n    /// @param targetChain The chain selector of the destination chain.\n    /// @param target The address of the recipient on the destination chain.\n    /// @param amount The amount of tokens to transfer.\n    /// @param nativeToken Whether the token is a native token.\n    /// @param extraArgs Extra arguments for CCIP\n    function getCCIPFee(uint64 targetChain, address target, uint256 amount, bool nativeToken, bytes memory extraArgs) public view returns (uint256) {\n        return getCCIPFee(targetChain, _toReceiver(target), amount, nativeToken, extraArgs);\n    }\n\n    /// @notice Gets the CCIP fee for a transfer.\n    /// @param targetChain The chain selector of the destination chain.\n    /// @param target The address of the recipient on the destination chain.\n    /// @param amount The amount of tokens to transfer.\n    /// @param nativeToken Whether the token is a native token.\n    /// @param extraArgs Extra arguments for CCIP\n    function getCCIPFee(uint64 targetChain, bytes memory target, uint256 amount, bool nativeToken, bytes memory extraArgs) public view returns (uint256) {\n        Client.EVMTokenAmount[] memory tokenAmounts = new Client.EVMTokenAmount[](1);\n        tokenAmounts[0] = Client.EVMTokenAmount(address(this), amount);\n        return _calculateFee(targetChain, _constructMessage(target, \"\", tokenAmounts, nativeToken, extraArgs));\n    }\n\n    /// @notice Construct a CCIP message.\n    /// @dev This function will create an EVM2AnyMessage struct with all the necessary information for tokens transfer.\n    /// @param receiver The address of the receiver.\n    /// @param amount The amount of the token to be transferred.\n    /// @return Client.EVM2AnyMessage Returns an EVM2AnyMessage struct which contains information for sending a CCIP message.\n    function constructTransferMessage(bytes memory receiver, uint256 amount, bytes memory extraArgs) internal view returns (Client.EVM2AnyMessage memory) {\n        Client.EVMTokenAmount[] memory tokenAmounts = new Client.EVMTokenAmount[](1);\n        tokenAmounts[0] = Client.EVMTokenAmount(address(this), amount);\n        return _constructMessage(receiver, \"\", tokenAmounts, extraArgs);\n    }\n}\n"
    },
    "contracts/erc20/CrossChainReference.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {CrossChainERC20} from \"./CrossChainERC20.sol\";\nimport {ERC20} from \"./ERC20.sol\";\nimport {Client} from \"@chainlink/contracts-ccip/src/v0.8/ccip/libraries/Client.sol\";\n\n/**\n * @dev A module for Frankencoin crosschain transfers with a reference number\n */\nabstract contract CrossChainReference is CrossChainERC20 {\n    event Transfer(address indexed from, address indexed to, uint256 amount, string ref);\n\n    // @dev: **to** is type bytes to support arbitrary destination chains without risk of unsafe conversion\n    event CrossTransfer(address indexed sender, address indexed from, uint64 toChain, bytes indexed to, uint256 amount, string ref);\n\n    constructor(address router, address linkToken) CrossChainERC20(router, linkToken) {}\n\n    // transfer within the erc20 context\n    function transfer(address recipient, uint256 amount, string calldata ref) public returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        emit Transfer(msg.sender, recipient, amount, ref);\n        return true;\n    }\n\n    function transferFrom(address owner, address recipient, uint256 amount, string calldata ref) public returns (bool) {\n        _useAllowance(owner, msg.sender, amount);\n        _transfer(owner, recipient, amount);\n        emit Transfer(owner, recipient, amount, ref);\n        return true;\n    }\n\n    // transfer within the cross chain context\n    function transfer(uint64 targetChain, address recipient, uint256 amount, string calldata ref) public returns (bool) {\n        return transfer(targetChain, _toReceiver(recipient), amount, \"\", ref);\n    }\n\n    function transfer(uint64 targetChain, address recipient, uint256 amount, Client.EVMExtraArgsV2 calldata extraArgs, string calldata ref) public returns (bool) {\n        return transfer(targetChain, _toReceiver(recipient), amount, Client._argsToBytes(extraArgs), ref);\n    }\n\n    function transfer(uint64 targetChain, bytes memory recipient, uint256 amount, bytes memory extraArgs, string calldata ref) public returns (bool) {\n        _crossTransfer(targetChain, msg.sender, recipient, amount, extraArgs, ref);\n        return true;\n    }\n\n    // cross transfer from\n    function transferFrom(uint64 targetChain, address owner, address recipient, uint256 amount, string calldata ref) public returns (bool) {\n        return transferFrom(targetChain, owner, _toReceiver(recipient), amount, \"\", ref);\n    }\n\n    function transferFrom(uint64 targetChain, address owner, address recipient, uint256 amount, Client.EVMExtraArgsV2 calldata extraArgs, string calldata ref) public returns (bool) {\n        return transferFrom(targetChain, owner, _toReceiver(recipient), amount, Client._argsToBytes(extraArgs), ref);\n    }\n\n    function transferFrom(uint64 targetChain, address owner, bytes memory recipient, uint256 amount, bytes memory extraArgs, string calldata ref) public returns (bool) {\n        _useAllowance(owner, msg.sender, amount);\n        _crossTransfer(targetChain, owner, recipient, amount, extraArgs, ref);\n        return true;\n    }\n\n    function _crossTransfer(uint64 targetChain, address from, bytes memory target, uint256 amount, bytes memory extraArgs, string calldata ref) private {\n        _transfer(from, address(this), amount);\n        _approve(address(this), address(ROUTER), amount);\n        _send(targetChain, constructTransferMessage(target, amount, extraArgs));\n        emit CrossTransfer(msg.sender, from, targetChain, target, amount, ref); // @dev: target is type bytes\n    }\n}\n"
    },
    "contracts/erc20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Copied and adjusted from OpenZeppelin\n// Adjustments:\n// - modifications to support ERC-677\n// - removed require messages to save space\n// - removed unnecessary require statements\n// - removed GSN Context\n// - upgraded to 0.8 to drop SafeMath\n// - let name() and symbol() be implemented by subclass\n// - infinite allowance support, with 2^255 and above considered infinite\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./IERC677Receiver.sol\";\n\n/**\n * @dev Implementation of the `IERC20` interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using `_mint`.\n * For a generic mechanism see `ERC20Mintable`.\n *\n * *For a detailed writeup see our guide [How to implement supply\n * mechanisms](https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226).*\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an `Approval` event is emitted on calls to `transferFrom`.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n */\n\nabstract contract ERC20 is IERC20 {\n    mapping(address account => uint256 balance) private _balances;\n\n    mapping(address account => mapping(address spender => uint256 allowance)) private _allowances;\n\n    uint256 internal constant INFINITY = (1 << 255);\n\n    uint256 private _totalSupply;\n\n    uint8 public immutable override decimals;\n\n    // Copied from https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4139/files#diff-fa792f7d08644eebc519dac2c29b00a54afc4c6a76b9ef3bba56c8401fe674f6\n    // Indicates an error related to the current balance of a sender. Used in transfers.\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\n    // Indicates a failure with the spender’s allowance. Used in transfers.\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\n\n    constructor(uint8 _decimals) {\n        decimals = _decimals;\n    }\n\n    /**\n     * @dev See `IERC20.totalSupply`.\n     */\n    function totalSupply() public view override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See `IERC20.balanceOf`.\n     */\n    function balanceOf(address account) public view override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See `IERC20.transfer`.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See `IERC20.allowance`.\n     */\n    function allowance(address owner, address spender) external view override returns (uint256) {\n        return _allowance(owner, spender);\n    }\n\n    function _allowance(address owner, address spender) internal view virtual returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See `IERC20.approve`.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 value) external override returns (bool) {\n        _approve(msg.sender, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev See `IERC20.transferFrom`.\n     *\n     * Emits an `Approval` event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of `ERC20`;\n     *\n     * Requirements:\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `value`.\n     * - the caller must have allowance for `sender`'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _useAllowance(sender, msg.sender, amount);\n        return true;\n    }\n\n    function _useAllowance(address owner, address spender, uint256 amount) internal {\n        uint256 currentAllowance = _allowance(owner, spender);\n        if (currentAllowance < INFINITY) {\n            // Only decrease the allowance if it was not set to 'infinite'\n            // Documented in github.com/aktionariat/contracts/blob/master/doc/infiniteallowance.md\n            if (currentAllowance < amount) revert ERC20InsufficientAllowance(owner, currentAllowance, amount);\n            _approve(owner, spender, currentAllowance - amount);\n        }\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to `transfer`, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a `Transfer` event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(recipient != address(0));\n\n        _beforeTokenTransfer(sender, recipient, amount);\n        if (_balances[sender] < amount) revert ERC20InsufficientBalance(sender, _balances[sender], amount);\n        _balances[sender] -= amount;\n        _balances[recipient] += amount;\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a `Transfer` event with `from` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address recipient, uint256 amount) internal virtual {\n        require(recipient != address(0));\n\n        _beforeTokenTransfer(address(0), recipient, amount);\n\n        _totalSupply += amount;\n        _balances[recipient] += amount;\n        emit Transfer(address(0), recipient, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a `Transfer` event with `to` set to the zero address.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _totalSupply -= amount;\n        _balances[account] -= amount;\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n     *\n     * This is internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an `Approval` event.\n     */\n    function _approve(address owner, address spender, uint256 value) internal {\n        _allowances[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n}\n"
    },
    "contracts/erc20/ERC20PermitLight.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Copied from https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol\n// and modified it.\n\npragma solidity ^0.8.0;\n\nimport \"./ERC20.sol\";\n\nabstract contract ERC20PermitLight is ERC20 {\n    /*//////////////////////////////////////////////////////////////\n                            EIP-2612 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(address account => uint256 nonce) public nonces;\n\n    /*//////////////////////////////////////////////////////////////\n                             EIP-2612 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\n\n        unchecked {\n            // unchecked to save a little gas with the nonce increment...\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"),\n                                bytes32(0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9),\n                                owner,\n                                spender,\n                                value,\n                                nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \"INVALID_SIGNER\");\n            _approve(recoveredAddress, spender, value);\n        }\n    }\n\n    function DOMAIN_SEPARATOR() public view returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    //keccak256(\"EIP712Domain(uint256 chainId,address verifyingContract)\");\n                    bytes32(0x47e79534a245952e8b16893a336b85a3d9ea9fa8c573f3d803afb92a79469218),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n}\n"
    },
    "contracts/erc20/IERC20.sol": {
      "content": "/**\n * SPDX-License-Identifier: MIT\n *\n * Copyright (c) 2016-2019 zOS Global Limited\n *\n */\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n * the optional functions; to access them see `ERC20Detailed`.\n */\n\ninterface IERC20 {\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns always true. Throws error on failure.\n     *\n     * Emits a `Transfer` event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through `transferFrom`. This is\n     * zero by default.\n     *\n     * This value can change when `approve` or `transferFrom` are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * > Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an `Approval` event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns always true. Throws error on failure.\n     *\n     * Emits a `Transfer` event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to `approve`. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/erc20/IERC677Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC677Receiver {\n    \n    function onTokenTransfer(address from, uint256 amount, bytes calldata data) external returns (bool);\n\n}"
    },
    "contracts/minting/IPosition.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../erc20/IERC20.sol\";\nimport \"../stablecoin/IFrankencoin.sol\";\n\ninterface IPosition {\n\n    function initialize(address parent, uint40 _expiration) external;\n\n    function hub() external view returns(address);\n\n    function original() external view returns (address);\n\n    function collateral() external view returns (IERC20);\n\n    function minimumCollateral() external view returns (uint256);\n\n    function challengePeriod() external view returns (uint40);\n\n    function expiration() external view returns (uint40);\n\n    function price() external view returns (uint256);\n\n    function deny(address[] calldata helpers, string calldata message) external;\n\n    function mint(address target, uint256 amount) external;\n\n    function repay(uint256 amount) external returns (uint256);\n\n    function adjust(uint256 newMinted, uint256 newCollateral, uint256 newPrice) external;\n\n    function minted() external view returns (uint256);\n\n    function availableForMinting() external view returns (uint256);\n\n    function reserveContribution() external view returns (uint24);\n\n    function withdrawCollateral(address target, uint256 amount) external;\n\n    function getUsableMint(uint256 totalMint, bool beforeFees) external view returns (uint256);\n\n    function getMintAmount(uint256 usableMint) external view returns (uint256);\n\n    function challengeData() external view returns (uint256 liqPrice, uint40 phase);\n\n    function notifyChallengeStarted(uint256 size) external;\n\n    function notifyChallengeAverted(uint256 size) external;\n\n    function notifyChallengeSucceeded(address _bidder, uint256 _size) external returns (address, uint256, uint256, uint32);\n\n    function forceSale(address buyer, uint256 collAmount, uint256 proceeds) external;\n\n}"
    },
    "contracts/minting/IPositionFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IPositionFactory {\n    function createNewPosition(\n        address _owner,\n        address _zchf,\n        address _collateral,\n        uint256 _minCollateral,\n        uint256 _initialLimit,\n        uint40 _initPeriodSeconds,\n        uint40 _duration,\n        uint40 _challengePeriod,\n        uint24 _riskPremiumPPM,\n        uint256 _liqPrice,\n        uint24 _reserve\n    ) external returns (address);\n\n    function clonePosition(address _existing) external returns (address);\n}\n"
    },
    "contracts/minting/MintingHub.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../erc20/IERC20.sol\";\nimport \"../rate/ILeadrate.sol\";\nimport \"../stablecoin/IFrankencoin.sol\";\nimport \"../minting/IPosition.sol\";\nimport \"../minting/IPositionFactory.sol\";\nimport \"./PositionRoller.sol\";\nimport \"../utils/Ownable.sol\";\n\n/**\n * @title Minting Hub\n * @notice The central hub for creating, cloning and challenging collateralized Frankencoin positions.\n * @dev Only one instance of this contract is required, whereas every new position comes with a new position\n * contract. Pending challenges are stored as structs in an array.\n */\ncontract MintingHub {\n    /**\n     * @notice Irrevocable fee in ZCHF when proposing a new position (but not when cloning an existing one).\n     */\n    uint256 public constant OPENING_FEE = 1000 * 10 ** 18;\n\n    /**\n     * @notice The challenger reward in parts per million (ppm) relative to the challenged amount, whereas\n     * challenged amount if defined as the challenged collateral amount times the liquidation price.\n     */\n    uint256 public constant CHALLENGER_REWARD = 20000; // 2%\n    uint256 public constant EXPIRED_PRICE_FACTOR = 10;\n\n    IPositionFactory private immutable POSITION_FACTORY; // position contract to clone\n\n    IFrankencoin public immutable zchf; // currency\n    PositionRoller public immutable roller; // helper to roll positions\n    ILeadrate public immutable rate; // to determine the interest rate\n\n    Challenge[] public challenges; // list of open challenges\n\n    /**\n     * @notice Map to remember pending postponed collateral returns.\n     * @dev It maps collateral => beneficiary => amount.\n     */\n    mapping(address collateral => mapping(address owner => uint256 amount)) public pendingReturns;\n\n    struct Challenge {\n        address challenger; // the address from which the challenge was initiated\n        uint40 start; // the start of the challenge\n        IPosition position; // the position that was challenged\n        uint256 size; // how much collateral the challenger provided\n    }\n\n    event PositionOpened(address indexed owner, address indexed position, address original, address collateral);\n    event ChallengeStarted(address indexed challenger, address indexed position, uint256 size, uint256 number);\n    event ChallengeAverted(address indexed position, uint256 number, uint256 size);\n    event ChallengeSucceeded(\n        address indexed position,\n        uint256 number,\n        uint256 bid,\n        uint256 acquiredCollateral,\n        uint256 challengeSize\n    );\n    event PostPonedReturn(address collateral, address indexed beneficiary, uint256 amount);\n    event ForcedSale(address pos, uint256 amount, uint256 priceE36MinusDecimals);\n\n    error UnexpectedPrice();\n    error InvalidPos();\n    error IncompatibleCollateral();\n    error InsufficientCollateral();\n\n    modifier validPos(address position) {\n        if (zchf.getPositionParent(position) != address(this)) revert InvalidPos();\n        _;\n    }\n\n    constructor(address _zchf, address _leadrate, address _roller, address _factory) {\n        zchf = IFrankencoin(_zchf);\n        rate = ILeadrate(_leadrate);\n        POSITION_FACTORY = IPositionFactory(_factory);\n        roller = PositionRoller(_roller);\n    }\n\n    /**\n     * @notice Open a collateralized loan position. See also https://docs.frankencoin.com/positions/open .\n     * @dev For a successful call, you must set an allowance for the collateral token, allowing\n     * the minting hub to transfer the initial collateral amount to the newly created position and to\n     * withdraw the fees.\n     *\n     * @param _collateralAddress        address of collateral token\n     * @param _minCollateral     minimum collateral required to prevent dust amounts\n     * @param _initialCollateral amount of initial collateral to be deposited\n     * @param _mintingMaximum    maximal amount of ZCHF that can be minted by the position owner\n     * @param _expirationSeconds position tenor in unit of timestamp (seconds) from 'now'\n     * @param _challengeSeconds  challenge period. Longer for less liquid collateral.\n     * @param _riskPremium       ppm of minted amount that is added to the applicible minting fee as a risk premium\n     * @param _liqPrice          Liquidation price with (36 - token decimals) decimals,\n     *                           e.g. 18 decimals for an 18 dec collateral, 36 decs for a 0 dec collateral.\n     * @param _reservePPM        ppm of minted amount that is locked as borrower's reserve, e.g. 20%\n     * @return address           address of created position\n     */\n    function openPosition(\n        address _collateralAddress,\n        uint256 _minCollateral,\n        uint256 _initialCollateral,\n        uint256 _mintingMaximum,\n        uint40 _initPeriodSeconds,\n        uint40 _expirationSeconds,\n        uint40 _challengeSeconds,\n        uint24 _riskPremium,\n        uint256 _liqPrice,\n        uint24 _reservePPM\n    ) public returns (address) {\n        {\n            require(_riskPremium <= 1000000);\n            require(CHALLENGER_REWARD <= _reservePPM && _reservePPM <= 1000000);\n            require(IERC20(_collateralAddress).decimals() <= 24); // leaves 12 digits for price\n            uint256 invalidAmount = IERC20(_collateralAddress).totalSupply() + 1;\n            try IERC20(_collateralAddress).transfer(address(0x123), invalidAmount) {\n                revert IncompatibleCollateral(); // we need a collateral that reverts on failed transfers\n            } catch Error(string memory /*reason*/) {\n            } catch Panic(uint /*errorCode*/) {\n            } catch (bytes memory /*lowLevelData*/) {\n            }\n            if (_initialCollateral < _minCollateral) revert InsufficientCollateral();\n            if (_minCollateral * _liqPrice < 5000 ether * 10 ** 18) revert InsufficientCollateral(); // must start with at least 5000 ZCHF worth of collateral\n        }\n        IPosition pos = IPosition(\n            POSITION_FACTORY.createNewPosition(\n                msg.sender,\n                address(zchf),\n                _collateralAddress,\n                _minCollateral,\n                _mintingMaximum,\n                _initPeriodSeconds,\n                _expirationSeconds,\n                _challengeSeconds,\n                _riskPremium,\n                _liqPrice,\n                _reservePPM\n            )\n        );\n        zchf.registerPosition(address(pos));\n        zchf.collectProfits(msg.sender, OPENING_FEE);\n        IERC20(_collateralAddress).transferFrom(msg.sender, address(pos), _initialCollateral);\n\n        emit PositionOpened(msg.sender, address(pos), address(pos), _collateralAddress);\n        return address(pos);\n    }\n\n   function clone(address parent, uint256 _initialCollateral, uint256 _initialMint, uint40 expiration) public returns (address) {\n        return clone(msg.sender, parent, _initialCollateral, _initialMint, expiration);\n   }\n\n    /**\n     * @notice Clones an existing position and immediately tries to mint the specified amount using the given collateral.\n     * @dev This needs an allowance to be set on the collateral contract such that the minting hub can get the collateral.\n     */\n    function clone(address owner, address parent, uint256 _initialCollateral, uint256 _initialMint, uint40 expiration) public validPos(parent) returns (address) {\n        address pos = POSITION_FACTORY.clonePosition(parent);\n        IPosition child = IPosition(pos);\n        child.initialize(parent, expiration);\n        zchf.registerPosition(pos);\n        IERC20 collateral = child.collateral();\n        if (_initialCollateral < child.minimumCollateral()) revert InsufficientCollateral();\n        collateral.transferFrom(msg.sender, pos, _initialCollateral); // collateral must still come from sender for security\n        emit PositionOpened(owner, address(pos), parent, address(collateral));\n        child.mint(owner, _initialMint);\n        Ownable(address(child)).transferOwnership(owner);\n        return address(pos);\n    }\n\n    /**\n     * @notice Launch a challenge (Dutch auction) on a position\n     * @param _positionAddr      address of the position we want to challenge\n     * @param _collateralAmount  amount of the collateral we want to challenge\n     * @param minimumPrice       position.price() to guard against the minter fruntrunning with a price change\n     * @return index of the challenge in challenge-array\n     */\n    function challenge(\n        address _positionAddr,\n        uint256 _collateralAmount,\n        uint256 minimumPrice\n    ) external validPos(_positionAddr) returns (uint256) {\n        IPosition position = IPosition(_positionAddr);\n        // challenger should be ok if frontrun by owner with a higher price\n        // in case owner fruntruns challenger with small price decrease to prevent challenge,\n        // the challenger should set minimumPrice to market price\n        if (position.price() < minimumPrice) revert UnexpectedPrice(); \n        IERC20(position.collateral()).transferFrom(msg.sender, address(this), _collateralAmount);\n        uint256 pos = challenges.length;\n        challenges.push(Challenge(msg.sender, uint40(block.timestamp), position, _collateralAmount));\n        position.notifyChallengeStarted(_collateralAmount);\n        emit ChallengeStarted(msg.sender, address(position), _collateralAmount, pos);\n        return pos;\n    }\n\n    /**\n     * @notice Post a bid in ZCHF given an open challenge.\n     *\n     * @dev In case that the collateral cannot be transfered back to the challenger (i.e. because the collateral token\n     * has a blacklist and the challenger is on it), it is possible to postpone the return of the collateral.\n     *\n     * @param _challengeNumber  index of the challenge as broadcast in the event\n     * @param size              how much of the collateral the caller wants to bid for at most\n     *                          (automatically reduced to the available amount)\n     * @param postponeCollateralReturn To postpone the return of the collateral to the challenger. Usually false.\n     */\n    function bid(uint32 _challengeNumber, uint256 size, bool postponeCollateralReturn) external {\n        Challenge memory _challenge = challenges[_challengeNumber];\n        (uint256 liqPrice, uint40 phase) = _challenge.position.challengeData();\n        size = _challenge.size < size ? _challenge.size : size; // cannot bid for more than the size of the challenge\n\n        if (block.timestamp <= _challenge.start + phase) {\n            _avertChallenge(_challenge, _challengeNumber, liqPrice, size);\n            emit ChallengeAverted(address(_challenge.position), _challengeNumber, size);\n        } else {\n            _returnChallengerCollateral(_challenge, _challengeNumber, size, postponeCollateralReturn);\n            (uint256 transferredCollateral, uint256 offer) = _finishChallenge(_challenge, liqPrice, phase, size);\n            emit ChallengeSucceeded(address(_challenge.position), _challengeNumber, offer, transferredCollateral, size);\n        }\n    }\n\n    function _finishChallenge(Challenge memory _challenge, uint256 liqPrice, uint40 phase, uint256 size) internal returns (uint256, uint256) {\n        // Repayments depend on what was actually minted, whereas bids depend on the available collateral\n        (address owner, uint256 collateral, uint256 repayment, uint32 reservePPM) = _challenge.position.notifyChallengeSucceeded(msg.sender, size);\n\n        // No overflow possible thanks to invariant (col * price <= limit * 10**18)\n        // enforced in Position.setPrice and knowing that collateral <= col.\n        uint256 offer = (_calculatePrice(_challenge.start + phase, phase, liqPrice) * collateral) / 10 ** 18;\n        zchf.transferFrom(msg.sender, address(this), offer); // get money from bidder\n        uint256 reward = (offer * CHALLENGER_REWARD) / 1000_000;\n        zchf.transfer(_challenge.challenger, reward); // pay out the challenger reward\n        uint256 fundsAvailable = offer - reward; // funds available after reward\n\n        // Example: available funds are 90, repayment is 50, reserve 20%. Then 20%*(90-50)=16 are collected as profits\n        // and the remaining 34 are sent to the position owner. If the position owner maxed out debt before the challenge\n        // started and the liquidation price was 100, they would be slightly better off as they would get away with 80\n        // instead of 40+36 = 76 in this example.\n        if (fundsAvailable > repayment) {\n            // The excess amount is distributed between the system and the owner using the reserve ratio\n            // At this point, we cannot rely on the liquidation price because the challenge might have been started as a\n            // response to an unreasonable increase of the liquidation price, such that we have to use this heuristic\n            // for excess fund distribution, which make position owners that maxed out their positions slightly better\n            // off in comparison to those who did not.\n            uint256 profits = (reservePPM * (fundsAvailable - repayment)) / 1000_000;\n            zchf.collectProfits(address(this), profits);\n            zchf.transfer(owner, fundsAvailable - repayment - profits);\n        } else if (fundsAvailable < repayment) {\n            zchf.coverLoss(address(this), repayment - fundsAvailable); // ensure we have enough to pay everything\n        }\n        zchf.burnWithoutReserve(repayment, reservePPM); // Repay the challenged part, example: 50 ZCHF leading to 10 ZCHf in implicit profits\n        return (collateral, offer);\n    }\n\n    function _avertChallenge(Challenge memory _challenge, uint32 number, uint256 liqPrice, uint256 size) internal {\n        require(block.timestamp != _challenge.start); // do not allow to avert the challenge in the same transaction, see CS-ZCHF-037\n        if (msg.sender == _challenge.challenger) {\n            // allow challenger to cancel challenge without paying themselves\n        } else {\n            zchf.transferFrom(msg.sender, _challenge.challenger, (size * liqPrice) / (10 ** 18));\n        }\n\n        _challenge.position.notifyChallengeAverted(size);\n        _challenge.position.collateral().transfer(msg.sender, size);\n        if (size < _challenge.size) {\n            challenges[number].size = _challenge.size - size;\n        } else {\n            require(size == _challenge.size);\n            delete challenges[number];\n        }\n    }\n\n    /**\n     * @notice Returns 'amount' of the collateral to the challenger and reduces or deletes the relevant challenge.\n     */\n    function _returnChallengerCollateral(\n        Challenge memory _challenge,\n        uint32 number,\n        uint256 amount,\n        bool postpone\n    ) internal {\n        _returnCollateral(_challenge.position.collateral(), _challenge.challenger, amount, postpone);\n        if (_challenge.size == amount) {\n            // bid on full amount\n            delete challenges[number];\n        } else {\n            // bid on partial amount\n            challenges[number].size -= amount;\n        }\n    }\n\n    /**\n     * @notice Calculates the current Dutch auction price.\n     * @dev Starts at the full price at time 'start' and linearly goes to 0 as 'phase2' passes.\n     */\n    function _calculatePrice(uint40 start, uint40 phase2, uint256 liqPrice) internal view returns (uint256) {\n        uint40 timeNow = uint40(block.timestamp);\n        if (timeNow <= start) {\n            return liqPrice;\n        } else if (timeNow >= start + phase2) {\n            return 0;\n        } else {\n            uint256 timeLeft = phase2 - (timeNow - start);\n            return (liqPrice / phase2) * timeLeft;\n        }\n    }\n\n    /**\n     * @notice Get the price per unit of the collateral for the given challenge.\n     * @dev The price comes with (36-collateral.decimals()) digits, such that multiplying it with the\n     * raw collateral amount always yields a price with 36 digits, or 18 digits after dividing by 10**18 again.\n     */\n    function price(uint32 challengeNumber) public view returns (uint256) {\n        Challenge memory _challenge = challenges[challengeNumber];\n        if (_challenge.challenger == address(0x0)) {\n            return 0;\n        } else {\n            (uint256 liqPrice, uint40 phase) = _challenge.position.challengeData();\n            return _calculatePrice(_challenge.start + phase, phase, liqPrice);\n        }\n    }\n\n    /**\n     * @notice Challengers can call this method to withdraw collateral whose return was postponed.\n     */\n    function returnPostponedCollateral(address collateral, address target) external {\n        uint256 amount = pendingReturns[collateral][msg.sender];\n        delete pendingReturns[collateral][msg.sender];\n        IERC20(collateral).transfer(target, amount);\n    }\n\n    function _returnCollateral(IERC20 collateral, address recipient, uint256 amount, bool postpone) internal {\n        if (postpone) {\n            // Postponing helps in case the challenger was blacklisted or otherwise cannot receive at the moment.\n            pendingReturns[address(collateral)][recipient] += amount;\n            emit PostPonedReturn(address(collateral), recipient, amount);\n        } else {\n            collateral.transfer(recipient, amount); // return the challenger's collateral\n        }\n    }\n\n    /**\n     * The applicable purchase price when forcing the sale of collateral of an expired position.\n     * \n     * The price starts at 10x the liquidation price at the expiration time, linearly declines to\n     * 1x liquidation price over the course of one challenge period, and then linearly declines\n     * less steeply to 0 over the course of another challenge period.\n     */\n    function expiredPurchasePrice(IPosition pos) public view returns (uint256) {\n        uint256 liqprice = pos.price();\n        uint256 expiration = pos.expiration();\n        if (block.timestamp <= expiration) {\n            return EXPIRED_PRICE_FACTOR * liqprice;\n        } else {\n            uint256 challengePeriod = pos.challengePeriod();\n            uint256 timePassed = block.timestamp - expiration;\n            if (timePassed <= challengePeriod) {\n                // from 10x liquidation price to 1x in first phase\n                uint256 timeLeft = challengePeriod - timePassed;\n                return liqprice + (((EXPIRED_PRICE_FACTOR - 1) * liqprice) / challengePeriod) * timeLeft;\n            } else if (timePassed < 2 * challengePeriod) {\n                // from 1x liquidation price to 0 in second phase\n                uint256 timeLeft = 2 * challengePeriod - timePassed;\n                return (liqprice / challengePeriod) * timeLeft;\n            } else {\n                // get collateral for free after both phases passed\n                return 0;\n            }\n        }\n    }\n\n    /**\n     * Buys up to the desired amount of the collateral asset from the given expired position using\n     * the applicable 'expiredPurchasePrice' in that instant.\n     */\n    function buyExpiredCollateral(IPosition pos, uint256 upToAmount) external returns (uint256) {\n        uint256 max = pos.collateral().balanceOf(address(pos));\n        uint256 amount = upToAmount > max ? max : upToAmount;\n        uint256 forceSalePrice = expiredPurchasePrice(pos);\n        uint256 costs = (forceSalePrice * amount) / 10 ** 18;\n        pos.forceSale(msg.sender, amount, costs);\n        emit ForcedSale(address(pos), amount, forceSalePrice);\n        return amount;\n    }\n}\n"
    },
    "contracts/minting/Position.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../utils/Ownable.sol\";\nimport \"../utils/MathUtil.sol\";\n\nimport \"../erc20/IERC20.sol\";\nimport \"../rate/ILeadrate.sol\";\nimport \"./IPosition.sol\";\nimport \"../stablecoin/IFrankencoin.sol\";\n\n// import \"hardhat/console.sol\";\n\n/**\n * @title Position\n * @notice A collateralized minting position.\n */\ncontract Position is Ownable, IPosition, MathUtil {\n    /**\n     * @notice Note that this contract is intended to be cloned. All clones will share the same values for\n     * the constant and immutable fields, but have their own values for the other fields.\n     */\n\n    /**\n     * @notice The zchf price per unit of the collateral below which challenges succeed, (36 - collateral.decimals) decimals\n     */\n    uint256 public price;\n\n    /**\n     * @notice Net minted amount, including reserve.\n     */\n    uint256 public minted;\n\n    /**\n     * @notice How much has been minted in total. This variable is only used in the parent position.\n     */\n    uint256 private totalMinted;\n\n    uint256 public immutable limit;\n\n    /**\n     * @notice Amount of the collateral that is currently under a challenge.\n     * Used to figure out whether there are pending challenges.\n     */\n    uint256 public challengedAmount;\n\n    /**\n     * @notice Challenge period in seconds.\n     */\n    uint40 public immutable challengePeriod;\n\n    /**\n     * @notice Timestamp when minting can start and the position no longer denied.\n     */\n    uint40 public immutable start;\n\n    /**\n     * @notice End of the latest cooldown. If this is in the future, minting is suspended.\n     */\n    uint40 public cooldown;\n\n    /**\n     * @notice Timestamp of the expiration of the position. After expiration, challenges cannot be averted\n     * any more. This is also the basis for fee calculations.\n     */\n    uint40 public expiration;\n\n    bool private closed;\n\n    /**\n     * @notice The original position to help identifying clones.\n     */\n    address public immutable original;\n\n    /**\n     * @notice Pointer to the minting hub.\n     */\n    address public immutable hub;\n\n    /**\n     * @notice The Frankencoin contract.\n     */\n    IFrankencoin public immutable zchf;\n\n    /**\n     * @notice The collateral token.\n     */\n    IERC20 public immutable override collateral;\n\n    /**\n     * @notice Minimum acceptable collateral amount to prevent dust.\n     */\n    uint256 public immutable override minimumCollateral;\n\n    /**\n     * @notice The interest in parts per million per year that is deducted when minting Frankencoins.\n     * To be paid upfront.\n     */\n    uint24 public immutable riskPremiumPPM;\n\n    /**\n     * @notice The reserve contribution in parts per million of the minted amount.\n     */\n    uint24 public immutable reserveContribution;\n\n    event MintingUpdate(uint256 collateral, uint256 price, uint256 minted);\n    event PositionDenied(address indexed sender, string message); // emitted if closed by governance\n\n    error InsufficientCollateral(uint256 needed, uint256 available);\n    error TooLate();\n    error RepaidTooMuch(uint256 excess);\n    error LimitExceeded(uint256 tried, uint256 available);\n    error ChallengeTooSmall();\n    error Expired(uint40 time, uint40 expiration);\n    error Alive();\n    error Closed();\n    error Hot();\n    error PriceIncreaseTooHigh(uint256 maxPrice, uint256 whatWasTried);\n    error Challenged();\n    error NotHub();\n    error NotOriginal();\n    error InvalidExpiration();\n    error AlreadyInitialized();\n\n    modifier alive() {\n        if (block.timestamp >= expiration) revert Expired(uint40(block.timestamp), expiration);\n        _;\n    }\n\n    // requires that the position has always been backed by a minimal amount of collateral\n    modifier backed() {\n        if (isClosed()) revert Closed();\n        _;\n    }\n\n    modifier expired() {\n        if (block.timestamp < expiration) revert Alive();\n        _;\n    }\n\n    modifier noCooldown() {\n        if (block.timestamp <= cooldown) revert Hot();\n        _;\n    }\n\n    modifier noChallenge() {\n        if (challengedAmount > 0) revert Challenged();\n        _;\n    }\n\n    modifier onlyHub() {\n        if (msg.sender != address(hub)) revert NotHub();\n        _;\n    }\n\n    modifier ownerOrRoller() {\n        if (msg.sender != address(IHub(hub).roller())) _requireOwner(msg.sender);\n        _;\n    }\n\n    /**\n     * @dev See MintingHub.openPosition\n     */\n    constructor(address _owner, address _hub, address _zchf, address _collateral,\n        uint256 _minCollateral, uint256 _initialLimit,\n        uint40 _initPeriod, uint40 _duration, uint40 _challengePeriod,\n        uint24 _riskPremiumPPM, uint256 _liqPrice, uint24 _reservePPM) {\n        require(_initPeriod >= 3 days); // must be at least three days, recommended to use higher values\n        _setOwner(_owner);\n        original = address(this);\n        hub = _hub;\n        zchf = IFrankencoin(_zchf);\n        collateral = IERC20(_collateral);\n        riskPremiumPPM = _riskPremiumPPM;\n        reserveContribution = _reservePPM;\n        minimumCollateral = _minCollateral;\n        challengePeriod = _challengePeriod;\n        start = uint40(block.timestamp) + _initPeriod; // at least three days time to deny the position\n        cooldown = start;\n        expiration = start + _duration;\n        limit = _initialLimit;\n        _setPrice(_liqPrice, _initialLimit);\n    }\n\n    /**\n     * Initialization method for clones.\n     * Can only be called once. Should be called immediately after creating the clone.\n     */\n    function initialize(address parent, uint40 _expiration) external onlyHub {\n        if (expiration != 0) revert AlreadyInitialized();\n        if (_expiration < block.timestamp || _expiration > Position(original).expiration()) revert InvalidExpiration(); // expiration must not be later than original\n        expiration = _expiration;\n        price = Position(parent).price();\n        _setOwner(hub);\n    }\n\n    /**\n     * Cloning a position is only allowed if the position is not challenged, not expired and not in cooldown.\n     */\n    function assertCloneable() external noChallenge noCooldown alive backed {}\n\n    /**\n     * Notify the original that some amount has been minted.\n     */\n    function notifyMint(uint256 mint_) external {\n        if (zchf.getPositionParent(msg.sender) != hub) revert NotHub();\n        totalMinted += mint_;\n    }\n\n    function notifyRepaid(uint256 repaid_) external {\n        if (zchf.getPositionParent(msg.sender) != hub) revert NotHub();\n        totalMinted -= repaid_;\n    }\n\n    /**\n     * Should only be called on the original position.\n     * Better use 'availableForMinting'.\n     */\n    function availableForClones() external view returns (uint256) {\n        // reserve capacity for the original to the extent the owner provided collateral\n        uint256 potential = (_collateralBalance() * price) / ONE_DEC18;\n        uint256 unusedPotential = minted > potential ? 0 : potential - minted;\n        if (totalMinted + unusedPotential >= limit) {\n            return 0;\n        } else {\n            return limit - totalMinted - unusedPotential;\n        }\n    }\n\n    /**\n     * The amount available for minting in this position family.\n     * \n     * Does not check if positions are challenged, closed, or under cooldown.\n     */\n    function availableForMinting() public view returns (uint256) {\n        if (address(this) == original) {\n            return limit - totalMinted;\n        } else {\n            return Position(original).availableForClones();\n        }\n    }\n\n    /**\n     * @notice Qualified pool share holders can call this method to immediately expire a freshly proposed position.\n     */\n    function deny(address[] calldata helpers, string calldata message) external {\n        if (block.timestamp >= start) revert TooLate();\n        zchf.reserve().checkQualified(msg.sender, helpers);\n        _close();\n        emit PositionDenied(msg.sender, message);\n    }\n\n    /**\n     * Closes the position by putting it into eternal cooldown.\n     * This allows the users to still withdraw the collateral that is left, but never to mint again.\n     */\n    function _close() internal {\n        closed = true;\n    }\n\n    function isClosed() public view returns (bool) {\n        return closed;\n    }\n\n    /**\n     * @notice This is how much the minter can actually use when minting ZCHF, with the rest being used\n     * assigned to the minter reserve or (if applicable) fees.\n     */\n    function getUsableMint(uint256 totalMint, bool afterFees) public view returns (uint256) {\n        if (afterFees) {\n            return (totalMint * (1000_000 - reserveContribution - calculateCurrentFee())) / 1000_000;\n        } else {\n            return (totalMint * (1000_000 - reserveContribution)) / 1000_000;\n        }\n    }\n\n    /**\n     * Returns the corresponding mint amount (disregarding the limit).\n     */\n    function getMintAmount(uint256 usableMint) external view returns (uint256) {\n        return usableMint == 0 ? 0 :(usableMint * 1000_000 - 1) / (1000_000 - reserveContribution - calculateCurrentFee()) + 1;\n    }\n\n    /**\n     * @notice \"All in one\" function to adjust the outstanding amount of ZCHF, the collateral amount,\n     * and the price in one transaction.\n     */\n    function adjust(uint256 newMinted, uint256 newCollateral, uint256 newPrice) external onlyOwner {\n        uint256 colbal = _collateralBalance();\n        if (newCollateral > colbal) {\n            collateral.transferFrom(msg.sender, address(this), newCollateral - colbal);\n        }\n        // Must be called after collateral deposit, but before withdrawal\n        if (newMinted < minted) {\n            zchf.burnFromWithReserve(msg.sender, minted - newMinted, reserveContribution);\n            _notifyRepaid(minted - newMinted);\n        }\n        if (newCollateral < colbal) {\n            _withdrawCollateral(msg.sender, colbal - newCollateral);\n        }\n        // Must be called after collateral withdrawal\n        if (newMinted > minted) {\n            _mint(msg.sender, newMinted - minted, newCollateral);\n        }\n        if (newPrice != price) {\n            _adjustPrice(newPrice);\n        }\n        emit MintingUpdate(newCollateral, newPrice, newMinted);\n    }\n\n    /**\n     * @notice Allows the position owner to adjust the liquidation price as long as there is no pending challenge.\n     * Lowering the liquidation price can be done with immediate effect, given that there is enough collateral.\n     * Increasing the liquidation price triggers a cooldown period of 3 days, during which minting is suspended.\n     */\n    function adjustPrice(uint256 newPrice) public onlyOwner {\n        _adjustPrice(newPrice);\n        emit MintingUpdate(_collateralBalance(), price, minted);\n    }\n\n    function _adjustPrice(uint256 newPrice) internal noChallenge alive backed {\n        if (newPrice > price) {\n            _preparePriceIncrease(newPrice);    \n        } else {\n            _checkCollateral(_collateralBalance(), newPrice);\n        }\n        _setPrice(newPrice, minted + availableForMinting());\n    }\n\n    function _preparePriceIncrease(uint256 newPrice) internal noCooldown {\n        if (newPrice > 3*price) revert PriceIncreaseTooHigh(3*price, newPrice);\n        _restrictMinting(3 days);\n    }\n\n    function _setPrice(uint256 newPrice, uint256 bounds) internal {\n        require(newPrice * minimumCollateral <= bounds * ONE_DEC18); // very important sanity check, see github.com/Frankencoin-ZCHF/FrankenCoin/issues/52\n        price = newPrice;\n    }\n\n    function _collateralBalance() internal view returns (uint256) {\n        return IERC20(collateral).balanceOf(address(this));\n    }\n\n    /**\n     * @notice Mint ZCHF as long as there is no open challenge, the position is not subject to a cooldown,\n     * and there is sufficient collateral.\n     */\n    function mint(address target, uint256 amount) public ownerOrRoller {\n        uint256 collateralBalance = _collateralBalance();\n        _mint(target, amount, collateralBalance);\n        emit MintingUpdate(collateralBalance, price, minted);\n    }\n\n    /**\n     * The applicable upfront fee in ppm when minting more Frankencoins based on the annual interest rate and\n     * the expiration of the position.\n     */\n    function calculateCurrentFee() public view returns (uint24) {\n        return calculateFee(expiration);\n    }\n\n    /**\n     * The applicable interest rate in ppm when minting more Frankencoins.\n     * It consists on the globally valid interest plus an individual risk premium.\n     */\n    function annualInterestPPM() public view returns (uint24) {\n        return IHub(hub).rate().currentRatePPM() + riskPremiumPPM;\n    }\n\n    /**\n     * The fee in ppm when cloning and minting with the given expiration date.\n     */\n    function calculateFee(uint256 exp) public view returns (uint24) {\n        uint256 time = block.timestamp < start ? start : block.timestamp;\n        uint256 timePassed = exp - time;\n        // Time resolution is in the range of minutes for typical interest rates.\n        uint256 feePPM = (timePassed * annualInterestPPM()) / 365 days;\n        return uint24(feePPM > 1000000 ? 1000000 : feePPM); // fee cannot exceed 100%\n    }\n\n    function _mint(address target, uint256 amount, uint256 collateral_) internal noChallenge noCooldown alive backed {\n        if (amount > availableForMinting()) revert LimitExceeded(amount, availableForMinting());\n        Position(original).notifyMint(amount);\n        zchf.mintWithReserve(target, amount, reserveContribution, calculateCurrentFee());\n        minted += amount;\n        _checkCollateral(collateral_, price);\n    }\n\n    function _restrictMinting(uint40 period) internal {\n        uint40 horizon = uint40(block.timestamp) + period;\n        if (horizon > cooldown) {\n            cooldown = horizon;\n        }\n    }\n\n    /**\n     * @notice Repay some ZCHF. If too much is repaid, the call fails.\n     * It is possible to repay while there are challenges, but the collateral is locked until all is clear again.\n     *\n     * The repaid amount should fulfill the following equation in order to close the position,\n     * i.e. bring the minted amount to 0:\n     * minted = amount + zchf.calculateAssignedReserve(amount, reservePPM)\n     *\n     * Under normal circumstances, this implies:\n     * amount = minted * (1000000 - reservePPM)\n     *\n     * E.g. if minted is 50 and reservePPM is 200000, it is necessary to repay 40 to be able to close the position.\n     */\n    function repay(uint256 amount) public returns (uint256) {\n        IERC20(zchf).transferFrom(msg.sender, address(this), amount);\n        uint256 actuallyRepaid = IFrankencoin(zchf).burnWithReserve(amount, reserveContribution);\n        _notifyRepaid(actuallyRepaid);\n        emit MintingUpdate(_collateralBalance(), price, minted);\n        return actuallyRepaid;\n    }\n\n    function _notifyRepaid(uint256 amount) internal {\n        if (amount > minted) revert RepaidTooMuch(amount - minted);\n        Position(original).notifyRepaid(amount);\n        minted -= amount;\n    }\n\n    /**\n     * Force the sale of some collateral after the position is expired.\n     * \n     * Can only be called by the minting hub and the minting hub is trusted to calculate the price correctly.\n     * The proceeds from the sale are first used to repay the outstanding balance and then (if anything is left)\n     * it is sent to the owner of the position.\n     * \n     * Do not allow a forced sale as long as there is an open challenge. Otherwise, a forced sale by the owner\n     * himself could remove any incentive to launch challenges shortly before the expiration. (CS-ZCHF2-001)\n     */\n    function forceSale(address buyer, uint256 collAmount, uint256 proceeds) external onlyHub expired noChallenge {\n        // send collateral to buyer\n        uint256 remainingCollateral = _sendCollateral(buyer, collAmount);\n        if (minted > 0) {\n            uint256 availableReserve = zchf.calculateAssignedReserve(minted, reserveContribution);\n            if (proceeds + availableReserve >= minted) {\n                // repay everything from the buyer's account\n                uint256 returnedReserve = zchf.burnFromWithReserve(buyer, minted, reserveContribution);\n                assert(returnedReserve == availableReserve);\n                // transfer the remaining purchase price from the buyer to the owner\n                zchf.transferFrom(buyer, owner, proceeds + returnedReserve - minted);\n                _notifyRepaid(minted);\n            } else {\n                // we can only repay a part, nothing left to pay to owner\n                zchf.transferFrom(buyer, address(this), proceeds);\n                if (remainingCollateral == 0) {\n                    // CS-ZCHF2-002, bad debt should be properly handled. In this case, the proceeds from \n                    // the forced sale did not suffice to repay the position and there is a loss\n                    zchf.coverLoss(address(this), minted - proceeds); // more than we need, but returned again on next line\n                    zchf.burnWithoutReserve(minted, reserveContribution);\n                    _notifyRepaid(minted);\n                } else {\n                    uint256 repaid = zchf.burnWithReserve(proceeds, reserveContribution);\n                    _notifyRepaid(repaid);\n                }\n            }\n        } else {\n            // wire funds directly to owner\n            zchf.transferFrom(buyer, owner, proceeds);\n        }\n        emit MintingUpdate(_collateralBalance(), price, minted);\n    }\n\n    /**\n     * @notice Withdraw any ERC20 token that might have ended up on this address.\n     * Withdrawing collateral is subject to the same restrictions as withdrawCollateral(...).\n     */\n    function withdraw(address token, address target, uint256 amount) external onlyOwner {\n        if (token == address(collateral)) {\n            withdrawCollateral(target, amount);\n        } else {\n            uint256 balance = _collateralBalance();\n            IERC20(token).transfer(target, amount);\n            require(balance == _collateralBalance()); // guard against double-entry-point tokens\n        }\n    }\n\n    /**\n     * @notice Withdraw collateral from the position up to the extent that it is still well collateralized afterwards.\n     * Not possible as long as there is an open challenge or the contract is subject to a cooldown.\n     *\n     * Withdrawing collateral below the minimum collateral amount formally closes the position.\n     */\n    function withdrawCollateral(address target, uint256 amount) public ownerOrRoller {\n        uint256 balance = _withdrawCollateral(target, amount);\n        emit MintingUpdate(balance, price, minted);\n    }\n\n    function _withdrawCollateral(address target, uint256 amount) internal noChallenge noCooldown returns (uint256) {\n        uint256 balance = _sendCollateral(target, amount);\n        _checkCollateral(balance, price);\n        return balance;\n    }\n\n    function _sendCollateral(address target, uint256 amount) internal returns (uint256) {\n        if (amount > 0) {\n            // Some weird tokens fail when trying to transfer 0 amounts\n            IERC20(collateral).transfer(target, amount);\n        }\n        uint256 balance = _collateralBalance();\n        if (balance < minimumCollateral) {\n            _close();\n        }\n        return balance;\n    }\n\n    /**\n     * @notice This invariant must always hold and must always be checked when any of the three\n     * variables change in an adverse way.\n     */\n    function _checkCollateral(uint256 collateralReserve, uint256 atPrice) internal view {\n        uint256 relevantCollateral = collateralReserve < minimumCollateral ? 0 : collateralReserve;\n        if (relevantCollateral * atPrice < minted * ONE_DEC18) revert InsufficientCollateral(relevantCollateral * atPrice, minted * ONE_DEC18);\n    }\n\n    /**\n     * @notice Returns the liquidation price and the durations for phase1 and phase2 of the challenge.\n     * Both phases are usually of equal duration, but near expiration, phase one is adjusted such that\n     * it cannot last beyond the expiration date of the position.\n     */\n    function challengeData() external view returns (uint256 liqPrice, uint40 phase) {\n        return (price, challengePeriod);\n    }\n\n    function notifyChallengeStarted(uint256 size) external onlyHub alive {\n        // Require minimum size. Collateral balance can be below minimum if it was partially challenged before.\n        if (size < minimumCollateral && size < _collateralBalance()) revert ChallengeTooSmall();\n        if (size == 0) revert ChallengeTooSmall();\n        challengedAmount += size;\n    }\n\n    /**\n     * @param size   amount of collateral challenged (dec18)\n     */\n    function notifyChallengeAverted(uint256 size) external onlyHub {\n        challengedAmount -= size;\n\n        // Don't allow minter to close the position immediately so challenge can be repeated before\n        // the owner has a chance to mint more on an undercollateralized position\n        _restrictMinting(1 days);\n    }\n\n    /**\n     * @notice Notifies the position that a challenge was successful.\n     * Triggers the payout of the challenged part of the collateral.\n     * Everything else is assumed to be handled by the hub.\n     *\n     * @param _bidder   address of the bidder that receives the collateral\n     * @param _size     amount of the collateral bid for\n     * @return (position owner, effective challenge size in ZCHF, amount to be repaid, reserve ppm)\n     */\n    function notifyChallengeSucceeded(\n        address _bidder,\n        uint256 _size\n    ) external onlyHub returns (address, uint256, uint256, uint32) {\n        challengedAmount -= _size;\n        uint256 colBal = _collateralBalance();\n        if (colBal < _size) {\n            _size = colBal;\n        }\n        uint256 repayment = colBal == 0 ? 0 : (minted * _size) / colBal; // for enormous colBal, this could be rounded to 0, which is ok\n        _notifyRepaid(repayment); // we assume the caller takes care of the actual repayment\n\n        // Give time for additional challenges before the owner can mint again. In particular,\n        // the owner might have added collateral only seconds before the challenge ended, preventing a close.\n        _restrictMinting(3 days);\n\n        uint256 newBalance = _sendCollateral(_bidder, _size); // transfer collateral to the bidder and emit update\n\n        emit MintingUpdate(newBalance, price, minted);\n\n        return (owner, _size, repayment, reserveContribution);\n    }\n}\n\ninterface IHub {\n    function rate() external view returns (ILeadrate);\n    function roller() external view returns (address);\n}\n"
    },
    "contracts/minting/PositionFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./Position.sol\";\nimport \"../stablecoin/IFrankencoin.sol\";\n\ncontract PositionFactory {\n    /**\n     * Create a completely new position in a newly deployed contract.\n     * Must be called through minting hub to be recognized as valid position.\n     */\n    function createNewPosition(\n        address _owner,\n        address _zchf,\n        address _collateral,\n        uint256 _minCollateral,\n        uint256 _initialLimit,\n        uint40 _initPeriod,\n        uint40 _duration,\n        uint40 _challengePeriod,\n        uint24 _riskPremiumPPM,\n        uint256 _liqPrice,\n        uint24 _reserve\n    ) external returns (address) {\n        return\n            address(\n                new Position(\n                    _owner,\n                    msg.sender,\n                    _zchf,\n                    _collateral,\n                    _minCollateral,\n                    _initialLimit,\n                    _initPeriod,\n                    _duration,\n                    _challengePeriod,\n                    _riskPremiumPPM,\n                    _liqPrice,\n                    _reserve\n                )\n            );\n    }\n\n    /**\n     * @notice clone an existing position. This can be a clone of another clone,\n     * or an original position.\n     * @param _parent address of the position we want to clone\n     * @return address of the newly created clone position\n     */\n    function clonePosition(address _parent) external returns (address) {\n        Position parent = Position(_parent);\n        parent.assertCloneable();\n        Position clone = Position(_createClone(parent.original()));\n        return address(clone);\n    }\n\n    // github.com/optionality/clone-factory/blob/32782f82dfc5a00d103a7e61a17a5dedbd1e8e9d/contracts/CloneFactory.sol\n    function _createClone(address target) internal returns (address result) {\n        bytes20 targetBytes = bytes20(target);\n        assembly {\n            let clone := mload(0x40)\n            mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(clone, 0x14), targetBytes)\n            mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            result := create(0, clone, 0x37)\n        }\n        require(result != address(0), \"ERC1167: create failed\");\n    }\n}\n"
    },
    "contracts/minting/PositionRoller.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../erc20/IERC20.sol\";\nimport \"../stablecoin/IFrankencoin.sol\";\nimport \"./IPosition.sol\";\nimport \"../utils/Ownable.sol\";\n\n/**\n * @title PositionRoller\n *\n * Helper to roll over a debt from an old position to a new one.\n * Both positions should have the same collateral. Otherwise, it does not make much sense.\n */\ncontract PositionRoller {\n\n    IFrankencoin private zchf;\n\n    error NotOwner(address pos);\n    error NotPosition(address pos);\n    error Log(uint256, uint256, uint256);\n\n    event Roll(address source, uint256 collWithdraw, uint256 repay, address target, uint256 collDeposit, uint256 mint);\n\n    constructor(address zchf_) {\n        zchf = IFrankencoin(zchf_);\n    }\n\n    /**\n     * Convenience method to roll and old position into a new one.\n     * \n     * Pre-condition is an allowance for the roller to spend the collateral assset on behalf of the caller,\n     * i.e. one should set collateral.approve(roller, collateral.balanceOf(sourcePosition));\n     * \n     * The following is assumed:\n     * - If the limit of the target position permits, the user wants to roll everything\n     * - The user does not want to add additional collateral, but excess collateral is returned\n     * - If not enough can be minted in the new position, it is ok for the roller to use ZCHF from the msg.sender\n     */\n    function rollFully(IPosition source, IPosition target) external {\n        rollFullyWithExpiration(source, target, target.expiration());\n    }\n\n    /**\n     * Like rollFully, but with a custom expiration date for the new position.\n     */\n    function rollFullyWithExpiration(IPosition source, IPosition target, uint40 expiration) public {\n        require(source.collateral() == target.collateral());\n        uint256 repay = findRepaymentAmount(source);\n        uint256 mintAmount = target.getMintAmount(repay);\n        uint256 collateralToWithdraw = IERC20(source.collateral()).balanceOf(address(source));\n        uint256 targetPrice = target.price();\n        uint256 depositAmount = (mintAmount * 10**18 + targetPrice - 1) / targetPrice; // round up\n        if (depositAmount > collateralToWithdraw){\n            // If we need more collateral than available from the old position, we opt for taking\n            // the missing funds from the caller instead of taking additional collateral from the caller\n            depositAmount = collateralToWithdraw;\n            mintAmount = depositAmount * target.price() / 10**18; // round down, rest will be taken from caller\n        }\n        roll(source, repay, collateralToWithdraw, target, mintAmount, depositAmount, expiration);\n    }\n\n    /**\n     * Doing a binary search is not very efficient, but guaranteed to return a valid result without rounding errors.\n     * To save gas costs, the frontend can also call this and other methods to calculate the right parameters and\n     * then call 'roll' directly.\n     */\n    function findRepaymentAmount(IPosition pos) public view returns (uint256) {\n        uint256 minted = pos.minted();\n        uint24 reservePPM = pos.reserveContribution();\n        if (minted == 0){\n            return 0;\n        }\n        uint256 higherResult = zchf.calculateFreedAmount(minted, reservePPM);\n        if (higherResult == minted){\n            return minted;\n        }\n        return binarySearch(minted, reservePPM, 0, 0, minted, higherResult);\n    }\n\n    // max call stack depth is 1024 in solidity. Binary search on 256 bit number takes at most 256 steps, so it should be fine.\n    function binarySearch(uint256 target, uint24 reservePPM, uint256 lowerBound, uint256 lowerResult, uint256 higherBound, uint256 higherResult) internal view returns (uint256) {\n        uint256 middle = (lowerBound + higherBound) / 2;\n        if (middle == lowerBound){\n            return higherBound; // we have reached max precision without exact match, return next higher result to be on the safe side\n        } else {\n            uint256 middleResult = zchf.calculateFreedAmount(middle, reservePPM);\n            if (middleResult == target){\n                return middle;\n            } else if (middleResult < target){\n                return binarySearch(target, reservePPM, middle, middleResult, higherBound, higherResult);\n            } else {\n                return binarySearch(target, reservePPM, lowerBound, lowerResult, middle, middleResult);\n            }\n        }\n    }\n\n    /**\n     * Rolls the source position into the target position using a flash loan.\n     * Both the source and the target position must recognize this roller.\n     * It is the responsibility of the caller to ensure that both positions are valid contracts.\n     * \n     * @param source The source position, must be owned by the msg.sender .\n     * @param repay The amount to flash loan in order to repay the source position and free up some or all collateral.\n     * @param collWithdraw Collateral to move from the source position to the msg.sender .\n     * @param target The target position. If not owned by msg.sender or if it does not have the desired expiration,\n     *               it is cloned to create a position owned by the msg.sender.\n     * @param mint The amount to be minted from the target position using collateral from msg.sender.\n     * @param collDeposit The amount of collateral to be send from msg.sender to the target position.\n     * @param expiration The desired expiration date for the target position.\n     */\n    function roll(IPosition source, uint256 repay, uint256 collWithdraw, IPosition target, uint256 mint, uint256 collDeposit, uint40 expiration) public valid(source) valid(target) own(source) {\n        zchf.mint(address(this), repay); // take a flash loan\n        source.repay(repay);\n        source.withdrawCollateral(msg.sender, collWithdraw);\n        if (mint > 0){\n            IERC20 targetCollateral = IERC20(target.collateral());\n            if (Ownable(address(target)).owner() != msg.sender || expiration != target.expiration()){\n                targetCollateral.transferFrom(msg.sender, address(this), collDeposit); // get the new collateral\n                targetCollateral.approve(target.hub(), collDeposit); // approve the new collateral and clone:\n                target = IPosition(IMintingHub(target.hub()).clone(msg.sender, address(target), collDeposit, mint, expiration));\n            } else {\n                // We can roll into the provided existing position\n                // We do not verify whether the target position has been created by the known minting hub in order\n                // to allow positions to be rolled into future versions of the minting hub\n                targetCollateral.transferFrom(msg.sender, address(target), collDeposit);\n                target.mint(msg.sender, mint);\n            }\n        }\n        zchf.burnFrom(msg.sender, repay); // repay the flash loan\n        emit Roll(address(source), collWithdraw, repay, address(target), collDeposit, mint);\n    }\n\n    modifier own(IPosition pos) {\n        if (Ownable(address(pos)).owner() != msg.sender) revert NotOwner(address(pos));\n        _;\n    }\n\n    modifier valid(IPosition pos) {\n        if (zchf.getPositionParent(address(pos)) == address(0x0)) revert NotPosition(address(pos));\n        _;\n    }\n}\n\ninterface IMintingHub {\n    function clone(address owner, address parent, uint256 _initialCollateral, uint256 _initialMint, uint40 expiration) external returns (address);\n}\n"
    },
    "contracts/rate/AbstractLeadrate.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../erc20/IERC20.sol\";\nimport \"../stablecoin/IFrankencoin.sol\";\nimport \"../minting/IPosition.sol\";\n\n/**\n * @title Leadrate (attempt at translating the nicely concise German term 'Leitzins')\n *\n * A module that can provide other modules with the lead interest rate for the system.\n * \n * This is an abstract module that is agnostic about the way the lead rate is updated.\n *\n **/\nabstract contract AbstractLeadrate {\n\n    // the following five variables are less than 256 bit so they should be stored\n    // in the same slot, making them cheap to access together, right?\n\n    uint24 public currentRatePPM; // 24 bit allows rates of up to 1670% per year\n\n    uint40 private anchorTime; // 40 bits for time in seconds spans up to 1000 human generations\n    uint64 private ticksAnchor; // in bips * seconds, uint88 allows up to\n\n    event RateChanged(uint24 newRate);\n\n    constructor(uint24 initialRatePPM) {\n        currentRatePPM = initialRatePPM;\n        anchorTime = uint40(block.timestamp);\n        ticksAnchor = 0;\n        emit RateChanged(initialRatePPM); // emit for init indexing, if wanted\n    }\n\n    /**\n     * Setting a previously proposed interest rate change into force.\n     */\n    function updateRate(uint24 rate) internal {\n        uint40 timeNow = uint40(block.timestamp);\n        ticksAnchor += (timeNow - anchorTime) * currentRatePPM;\n        anchorTime = timeNow;\n        currentRatePPM = rate;\n        emit RateChanged(rate);\n    }\n\n    /**\n     * Total accumulated 'interest ticks' since this contract was deployed.\n     * One 'tick' is a ppm-second, so one months of 12% annual interest is\n     *   120000*30*24*3600 = 311040000000 ticks.\n     * Two months of 6% annual interest would result in the same number of\n     * ticks. For simplicity, this is linear, so there is no \"interest on interest\".\n     */\n    function currentTicks() public view returns (uint64) {\n        return ticks(block.timestamp);\n    }\n\n    function ticks(uint256 timestamp) public view returns (uint64) {\n        return ticksAnchor + (uint64(timestamp) - anchorTime) * currentRatePPM;\n    }\n\n}\n"
    },
    "contracts/rate/BridgedLeadrate.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {CCIPReceiver} from \"@chainlink/contracts-ccip/src/v0.8/ccip/applications/CCIPReceiver.sol\";\nimport {Client} from \"@chainlink/contracts-ccip/src/v0.8/ccip/libraries/Client.sol\";\nimport \"../erc20/IERC20.sol\";\nimport \"../stablecoin/IFrankencoin.sol\";\nimport \"../minting/IPosition.sol\";\nimport \"./AbstractLeadrate.sol\";\n\n/**\n * @title Leadrate (attempt at translating the nicely concise German term 'Leitzins')\n *\n * A contract that receives updates from mainnet about interest rate changes. It keeps a \"tick\" counter that \n * increases with the accumulated interest (i.e. the ticks accrue twice as fast over time if the interest rate\n * is twice as high).\n *\n **/\ncontract BridgedLeadrate is AbstractLeadrate, CCIPReceiver {\n    uint64 public immutable MAINNET_CHAIN_SELECTOR;\n    address public immutable MAINNET_LEADRATE_ADDRESS;\n\n    error InvalidSourceChain();\n    error InvalidSender();\n\n    constructor(address router, uint24 initialRatePPM, uint64 mainnetChainSelector, address mainnetLeadrate) AbstractLeadrate(initialRatePPM) CCIPReceiver(router) {\n        MAINNET_CHAIN_SELECTOR = mainnetChainSelector;\n        MAINNET_LEADRATE_ADDRESS = mainnetLeadrate;\n    }\n\n    /// @notice Update the lead rate.\n    /// @param any2EvmMessage The message to process.\n    function _ccipReceive(Client.Any2EVMMessage memory any2EvmMessage) internal override {\n        if (any2EvmMessage.sourceChainSelector != MAINNET_CHAIN_SELECTOR) revert InvalidSourceChain();\n        if (abi.decode(any2EvmMessage.sender, (address)) != MAINNET_LEADRATE_ADDRESS) revert InvalidSender();\n\n        uint24 newRate = abi.decode(any2EvmMessage.data, (uint24));\n        updateRate(newRate);\n    }\n}\n"
    },
    "contracts/rate/ILeadrate.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface ILeadrate {\n   function currentRatePPM() external view returns (uint24);\n   function currentTicks() external view returns (uint64);\n}\n"
    },
    "contracts/rate/Leadrate.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../erc20/IERC20.sol\";\nimport \"../stablecoin/IFrankencoin.sol\";\nimport \"../minting/IPosition.sol\";\nimport \"../equity/IGovernance.sol\";\nimport \"./AbstractLeadrate.sol\";\n\n/**\n * @title Leadrate (attempt at translating the nicely concise German term 'Leitzins')\n *\n * A module that can provide other modules with the lead interest rate for the system.\n *\n **/\ncontract Leadrate is AbstractLeadrate {\n\n    IGovernance public immutable equity;\n\n    // the following five variables are less than 256 bit so they should be stored\n    // in the same slot, making them cheap to access together, right?\n\n    uint24 public nextRatePPM;\n    uint40 public nextChange;\n\n    event RateProposed(address who, uint24 nextRate, uint40 nextChange);\n    error NoPendingChange();\n    error ChangeNotReady();\n\n    constructor(IGovernance equity_, uint24 initialRatePPM) AbstractLeadrate(initialRatePPM) {\n        equity = equity_;\n        nextRatePPM = initialRatePPM;\n        nextChange = uint40(block.timestamp);\n    }\n\n    /**\n     * Proposes a new interest rate that will automatically be applied after seven days.\n     * To cancel a proposal, just overwrite it with a new one proposing the current rate.\n     */\n    function proposeChange(uint24 newRatePPM_, address[] calldata helpers) external {\n        equity.checkQualified(msg.sender, helpers);\n        nextRatePPM = newRatePPM_;\n        nextChange = uint40(block.timestamp + 7 days);\n        emit RateProposed(msg.sender, nextRatePPM, nextChange);\n    }\n\n    /**\n     * Setting a previously proposed interest rate change into force.\n     */\n    function applyChange() external {\n        if (currentRatePPM == nextRatePPM) revert NoPendingChange();\n        uint40 timeNow = uint40(block.timestamp);\n        if (timeNow < nextChange) revert ChangeNotReady();\n        super.updateRate(nextRatePPM);\n    }\n\n}\n"
    },
    "contracts/savings/AbstractSavings.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../stablecoin/IFrankencoin.sol\";\nimport \"../rate/AbstractLeadrate.sol\";\n\n/**\n * @title Savings\n *\n * Module to enable savings based on a Leadrate (\"Leitzins\") module.\n * \n * Users can deposit Frankencoins into the module and earn an interest on the \n * deposited amount. The deposited Frankencoins stay in the module (no lending\n * or use by others) and are kept on separate accounts within the module.\n * That means legal segregation is preserved thanks to the internal accounting.\n *\n * As the interest rate changes, the speed at which yield is accumulated is\n * adjusted. The ticks counter serves as the basis for calculating the interest\n * due for the individual accounts.\n *\n * Interest only starts to accumulate after a delay of three days in order to\n * disincentivize going in and out of the savings module for very short time spans.\n * \n * Frontends or wallets can optionally specify a referrer that gets up to\n * 25% of the earned interest. The user can get rid of the referrer at any time by\n * calling dropReferred.\n */\nabstract contract AbstractSavings is AbstractLeadrate {\n    \n    uint64 public immutable INTEREST_DELAY = uint64(3 days);\n\n    IFrankencoin public immutable ZCHF;\n\n    mapping(address => Account) public savings;\n\n    struct Account {\n        uint192 saved;\n        uint64 ticks;\n        address referrer;\n        uint32 referralFeePPM;\n    }\n\n    event Saved(address indexed account , uint192 amount);\n    event InterestCollected(address indexed account, uint256 interest, uint256 referrerFee);\n    event Withdrawn(address indexed account, uint192 amount);\n\n    error FundsLocked(uint40 remainingSeconds);\n\n    // The module is considered disabled if the interest is zero or about to become zero within three days.\n    error ModuleDisabled();\n\n    error ReferralFeeTooHigh(uint32 fee);\n\n    constructor(IFrankencoin zchf){\n        ZCHF = zchf;\n    }\n\n    /**\n     * Shortcut for refreshBalance(msg.sender)\n     */\n    function refreshMyBalance() public returns (uint192) {\n        return refreshBalance(msg.sender);\n    }\n\n    /**\n     * Collects the accrued interest and adds it to the account.\n     *\n     * It can be beneficial to do so every now and then in order to start collecting\n     * interest on the accrued interest.\n     */\n    function refreshBalance(address owner) public returns (uint192) {\n        return refresh(owner).saved;\n    }\n\n    function refresh(address accountOwner) internal returns (Account storage) {\n        Account storage account = savings[accountOwner];\n        uint64 ticks = currentTicks();\n        if (ticks > account.ticks) {\n            uint192 earnedInterest = calculateInterest(account, ticks);\n            if (earnedInterest > 0) {\n                // collect interest as you go and trigger accounting event\n                ZCHF.coverLoss(address(this), earnedInterest);\n                uint192 referralFee = deductTransferReferralFee(account, earnedInterest);\n                account.saved += (earnedInterest - referralFee);\n                emit InterestCollected(accountOwner, earnedInterest, referralFee);\n            }\n            account.ticks = ticks;\n        }\n        return account;\n    }\n\n    function accruedInterest(address accountOwner) public view returns (uint192) {\n        return accruedInterest(accountOwner, block.timestamp);\n    }\n\n    function accruedInterest(address accountOwner, uint256 timestamp) public view returns (uint192) {\n        Account memory account = savings[accountOwner];\n        return calculateInterest(account, ticks(timestamp));\n    }\n\n    function calculateInterest(Account memory account, uint64 ticks) public pure returns (uint192) {\n        if (ticks <= account.ticks || account.ticks == 0) {\n            return 0;\n        } else {\n            return uint192((uint256(ticks - account.ticks) * account.saved) / 1000000 / 365 days);\n        }\n    }\n    \n    /**\n     * Save 'amount'.\n     */\n    function save(uint192 amount) public {\n        save(msg.sender, amount);\n    }\n\n    function adjust(uint192 targetAmount) public {\n        Account storage balance = refresh(msg.sender);\n        if (balance.saved < targetAmount) {\n            save(targetAmount - balance.saved);\n        } else if (balance.saved > targetAmount) {\n            withdraw(msg.sender, balance.saved - targetAmount);\n        }\n    }\n\n    /**\n     * Send 'amount' to the account of the provided owner.\n     * The funds sent to the account are locked for a while, depending on how much already is in there.\n     */\n    function save(address owner, uint192 amount) public {\n        if (currentRatePPM == 0) revert ModuleDisabled();\n       // if (nextRatePPM == 0 && (nextChange <= block.timestamp + INTEREST_DELAY)) revert ModuleDisabled(); TODO: figure out why this was in there\n        Account storage balance = refresh(owner);\n        ZCHF.transferFrom(msg.sender, address(this), amount);\n        uint64 ticks = currentTicks();\n        assert(balance.ticks >= ticks);\n        uint256 saved = balance.saved;\n        uint64 weightedAverage = uint64(\n            (saved * (balance.ticks - ticks) + uint256(amount) * currentRatePPM * INTEREST_DELAY) / (saved + amount)\n        );\n        balance.saved += amount;\n        balance.ticks = ticks + weightedAverage;\n        emit Saved(owner, amount);\n    }\n\n    /**\n     * Withdraw up to 'amount' to the target address.\n     * When trying to withdraw more than available, all that is available is withdrawn.\n     * Returns the acutally transferred amount.\n     */\n    function withdraw(address target, uint192 amount) public returns (uint256) {\n        Account storage account = refresh(msg.sender);\n        if (amount >= account.saved) {\n            amount = account.saved;\n            delete savings[msg.sender];\n        } else {\n            account.saved -= amount;\n        }\n        ZCHF.transfer(target, amount);\n        emit Withdrawn(msg.sender, amount);\n        return amount;\n    }\n\n    /**\n     * REFERRAL LOGIC\n     * \n     * The following functions can be used by a frontend or wallet contains functions to\n     * access the savings features of the Frankencoin system. It allows the frontend or\n     * wallet to set a referrer and a referral fee when calling save or adjust, but not\n     * when withdrawing. The referral fee can be up to 25% (250'000 ppm). It is deducted\n     * from the collected interest.\n     * \n     * The user can drop or change the referrer at any time, so the fee is not very sticky.\n     * The magnitude of the fee that can be charged mainly depends on how convenient the\n     * frontend or wallet is in comparison to the user directly interfering with the system\n     * himself. So economically, it really is a frontend fee that can only be charged to\n     * the extent that the frontend provides a more convenient way of interaction with the\n     * protocol and the users are willing to pay for that convenience.\n     */\n\n    /**\n     * Save the given amount and set the referrer to earn a fee on the collected interest.\n     * \n     * Referral fee is given in parts per million and can be at most 250'000, which is 25%.\n     */\n    function save(uint192 amount, address referrer, uint24 referralFeePPM) public {\n        save(msg.sender, amount);\n        setReferrer(referrer, referralFeePPM);\n    }\n\n    /**\n     * Withdraw the given amount and set the referrer to earn a fee on the collected interest.\n     * \n     * Referral fee is given in parts per million and can be at most 250'000, which is 25%.\n     */\n    function withdraw(uint192 amount, address referrer, uint24 referralFeePPM) public {\n        withdraw(msg.sender, amount);\n        setReferrer(referrer, referralFeePPM);\n    }\n\n    /**\n     * Adjust to the given amount and set the referrer to earn a fee on the collected interest.\n     * \n     * Referral fee is given in parts per million and can be at most 250'000, which is 25%.\n     */\n    function adjust(uint192 targetAmount, address referrer, uint24 referralFeePPM) public {\n        adjust(targetAmount);\n        setReferrer(referrer, referralFeePPM);\n    }\n\n    /**\n     * Remove the referrer.\n     */\n    function dropReferrer() public {\n        refresh(msg.sender); // pay accrued referral fee before dropping referrer\n        setReferrer(address(0x0), 0);\n    }\n\n    function setReferrer(address referrer, uint32 referralFeePPM) internal {\n        if (referralFeePPM > 250_000) revert ReferralFeeTooHigh(referralFeePPM); // don't allow more than 25%\n        savings[msg.sender].referrer = referrer;\n        savings[msg.sender].referralFeePPM = referralFeePPM;\n    }\n\n    function deductTransferReferralFee(Account memory balance, uint192 earnedInterest) internal returns (uint192) {\n        if (balance.referrer != address(0x0)){\n            uint256 referralFee = uint256(earnedInterest) * balance.referralFeePPM / 1000000;\n            ZCHF.transfer(balance.referrer, referralFee);\n            return uint192(referralFee);\n        } else {\n            return 0;\n        }\n    }\n\n}\n\ninterface IInterestSource {\n    function coverLoss(address source, uint256 amount) external;\n}\n"
    },
    "contracts/savings/BridgedSavings.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../rate/BridgedLeadrate.sol\";\nimport \"./AbstractSavings.sol\";\nimport \"../erc20/IERC20.sol\";\n\n/**\n * @title BridgedSavings\n *\n * Module to enable savings on module bridged chains.\n */\ncontract BridgedSavings is AbstractSavings, BridgedLeadrate {\n    constructor(\n        IFrankencoin zchf_,\n        address router_,\n        uint24 initialRatePPM,\n        uint64 mainnetChainSelector,\n        address mainnetLeadrate\n    ) AbstractSavings(zchf_) BridgedLeadrate(router_, initialRatePPM, mainnetChainSelector, mainnetLeadrate) {}\n}\n"
    },
    "contracts/savings/Savings.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../stablecoin/IFrankencoin.sol\";\nimport \"../rate/Leadrate.sol\";\nimport \"./AbstractSavings.sol\";\n\n/**\n * @title Savings\n *\n * Module to enable savings based on a Leadrate (\"Leitzins\") module on mainnet.\n */\ncontract Savings is Leadrate, AbstractSavings {\n\n    constructor(IFrankencoin zchf_, uint24 initialRatePPM) AbstractSavings(zchf_) Leadrate(zchf_.reserve(), initialRatePPM) {\n    }\n\n}\n"
    },
    "contracts/stablecoin/BridgedFrankencoin.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../erc20/CrossChainReference.sol\";\nimport \"../erc20/ERC20PermitLight.sol\";\nimport \"../equity/Equity.sol\";\nimport \"../equity/IGovernance.sol\";\nimport \"../equity/BridgedGovernance.sol\";\nimport \"./IBasicFrankencoin.sol\";\n\n/**\n * @title Bridged Frankencoin ERC-20 Token\n *\n * Like its mainnet counterpart, it has the capability to add minting modules. This allows to\n * potentially add similar collateralized minting methods as in the mainnet Frankencoin.\n * \n * Minting modules are extremely powerful. They can mint, move, and burn Frankencoins on arbitrary addresses.\n * A typical minting module is the CCIP Token Manager that mints tokens as they arrive from other chains or\n * burns them when sent away again.\n *\n * The bridged Frankencoin relies on the bridged governance module to veto bad proposals for new minters.\n * \n * System income (e.g. from proposal fees) is accumualted on the governance address (this could be any address,\n * but on mainnet, it is also the governance module that contains the equity capital). Furthermore, the contract\n * keeps track of accumulated costs (losses), for example when the Savings module pays out interests.\n * \n * The accumulated profit or loss should be synchronized back to mainnet from time to time using a CCIP\n * message.\n */\ncontract BridgedFrankencoin is CrossChainReference, ERC20PermitLight, IBasicFrankencoin {\n    /**\n     * @notice Minimal fee and application period when suggesting a new minter.\n     */\n    uint256 public constant MIN_FEE = 1000 * (10 ** 18);\n    uint256 public immutable MIN_APPLICATION_PERIOD; // for example 10 days\n    address public immutable BRIDGE_ACCOUNTING;\n    uint64 public immutable MAINNET_CHAIN_SELECTOR;\n    address public immutable CCIP_ADMIN;\n\n    /**\n     * @notice The contract that holds the reserve.\n     */\n    IGovernance public immutable override reserve;\n\n    /**\n     * @notice Map of minters to approval time stamps. If the time stamp is in the past, the minter contract is allowed\n     * to mint Frankencoins.\n     */\n    mapping(address minter => uint256 validityStart) public minters;\n\n    /**\n     * @notice List of positions that are allowed to mint and the minter that registered them.\n     * \n     * This is not used in the bridged Frankencoins for now, but can be useful once we want to introduce collateralized\n     * minting like on mainnet.\n     */\n    mapping(address position => address registeringMinter) public positions;\n\n    uint256 public accruedLoss;\n    bool public initialized;\n\n    event AccountingSynchronized(uint256 profit, uint256 losses);\n    event MinterApplied(address indexed minter, uint256 applicationPeriod, uint256 applicationFee, string message);\n    event MinterDenied(address indexed minter, string message);\n    event Loss(address indexed reportingMinter, uint256 amount);\n    event Profit(address indexed reportingMinter, uint256 amount);\n\n    error PeriodTooShort();\n    error FeeTooLow();\n    error AlreadyRegistered();\n    error NotMinter();\n    error TooLate();\n    error AlreadyInitialized();\n    error InvalidInput();\n\n    modifier minterOnly() {\n        if (!isMinter(msg.sender) && !isMinter(positions[msg.sender])) revert NotMinter();\n        _;\n    }\n\n    /**\n     * @notice Initiates the Frankencoin with the provided minimum application period for new plugins\n     * in seconds, for example 10 days, i.e. 3600*24*10 = 864000\n     */\n    constructor(IGovernance reserve_, address router_, uint256 _minApplicationPeriod, address _linkToken, uint64 _mainnetChainSelector, address _bridgeAccounting, address _ccipAdmin) ERC20(18) CrossChainReference(router_, _linkToken) {\n        MIN_APPLICATION_PERIOD = _minApplicationPeriod;\n        reserve = reserve_;\n        MAINNET_CHAIN_SELECTOR = _mainnetChainSelector;\n        BRIDGE_ACCOUNTING = _bridgeAccounting;\n        CCIP_ADMIN = _ccipAdmin;\n    }\n\n    function name() external pure override returns (string memory) {\n        return \"Frankencoin\";\n    }\n\n    function symbol() external pure override returns (string memory) {\n        return \"ZCHF\";\n    }\n\n    /// @notice Initializes the bridged Frankencoin token.\n    /// @dev This function is only callable once.\n    /// @param _minters List of addresses that are allowed to mint Frankencoins.\n    /// @param _messages List of messages that are displayed to the user when the minter is applied.\n    function initialize(address[] calldata _minters, string[] calldata _messages) external {\n        if (initialized) revert AlreadyInitialized();\n        if (_minters.length != _messages.length) revert InvalidInput();\n\n        for (uint256 i = 0; i < _minters.length; i++) {\n            minters[_minters[i]] = block.timestamp;\n            emit MinterApplied(_minters[i], 0, 0, _messages[i]);\n        }\n        initialized = true;\n    }\n\n    /**\n     * @notice Publicly accessible method to suggest a new way of minting Frankencoin.\n     * @dev The caller has to pay an application fee that is irrevocably lost even if the new minter is vetoed.\n     * The caller must assume that someone will veto the new minter unless there is broad consensus that the new minter\n     * adds value to the Frankencoin system. Complex proposals should have application periods and applications fees\n     * above the minimum. It is assumed that over time, informal ways to coordinate on new minters emerge. The message\n     * parameter might be useful for initiating further communication. Maybe it contains a link to a website describing\n     * the proposed minter.\n     *\n     * @param _minter              An address that is given the permission to mint Frankencoins\n     * @param _applicationPeriod   The time others have to veto the suggestion, at least MIN_APPLICATION_PERIOD\n     * @param _applicationFee      The fee paid by the caller, at least MIN_FEE\n     * @param _message             An optional human readable message to everyone watching this contract\n     */\n    function suggestMinter(address _minter, uint256 _applicationPeriod, uint256 _applicationFee, string calldata _message) external override {\n        if (_applicationPeriod < MIN_APPLICATION_PERIOD) revert PeriodTooShort();\n        if (_applicationFee < MIN_FEE) revert FeeTooLow();\n        if (minters[_minter] != 0) revert AlreadyRegistered();\n        _collectProfits(address(this), msg.sender, _applicationFee);\n        minters[_minter] = block.timestamp + _applicationPeriod;\n        emit MinterApplied(_minter, _applicationPeriod, _applicationFee, _message);\n    }\n\n    /**\n     * @notice Make the system more user friendly by skipping the allowance in many cases.\n     * @dev We trust minters and the positions they have created to mint and burn as they please, so\n     * giving them arbitrary allowances does not pose an additional risk.\n     */\n    function _allowance(address owner, address spender) internal view override returns (uint256) {\n        uint256 explicit = super._allowance(owner, spender);\n        if (explicit > 0) {\n            return explicit; // don't waste gas checking minter\n        } else if (isMinter(spender) || isMinter(getPositionParent(spender)) || spender == address(reserve)) {\n            return INFINITY;\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n     * @notice Allows minters to register collateralized debt positions, thereby giving them the ability to mint Frankencoins.\n     * @dev It is assumed that the responsible minter that registers the position ensures that the position can be trusted.\n     */\n    function registerPosition(address _position) external override {\n        if (!isMinter(msg.sender)) revert NotMinter();\n        positions[_position] = msg.sender;\n    }\n\n    /**\n     * @notice Qualified pool share holders can deny minters during the application period.\n     * @dev Calling this function is relatively cheap thanks to the deletion of a storage slot.\n     */\n    function denyMinter(address _minter, address[] calldata _helpers, string calldata _message) external override {\n        if (block.timestamp > minters[_minter]) revert TooLate();\n        reserve.checkQualified(msg.sender, _helpers);\n        delete minters[_minter];\n        emit MinterDenied(_minter, _message);\n    }\n\n    function mint(address _target, uint256 _amount) external override minterOnly {\n        _mint(_target, _amount);\n    }\n\n    /**\n     * Anyone is allowed to burn their ZCHF.\n     */\n    function burn(uint256 _amount) external {\n        _burn(msg.sender, _amount);\n    }\n\n    /**\n     * @notice Burn someone elses ZCHF.\n     */\n    function burnFrom(address _owner, uint256 _amount) external override minterOnly {\n        _burn(_owner, _amount);\n    }\n\n    function canMint(address _minterOrPosition) public view returns (bool) {\n        return isMinter(_minterOrPosition) || isMinter(positions[_minterOrPosition]);\n    }\n\n    /**\n     * @notice Notify the Frankencoin that a minter lost economic access to some coins. This does not mean that the coins are\n     * literally lost. It just means that some ZCHF will likely never be repaid and that in order to bring the system\n     * back into balance, the lost amount of ZCHF must be removed from the reserve instead.\n     *\n     * For example, if a minter printed 1 million ZCHF for a mortgage and the mortgage turned out to be unsound with\n     * the house only yielding 800'000 in the subsequent auction, there is a loss of 200'000 that needs to be covered\n     * by the reserve.\n     */\n    function coverLoss(address source, uint256 _amount) external minterOnly {\n        uint256 reserveLeft = balanceOf(address(reserve));\n        if (_amount > reserveLeft) {\n            accruedLoss += (_amount - reserveLeft);\n            _mint(address(reserve), _amount - reserveLeft);\n        }\n        _transfer(address(reserve), source, _amount);\n        emit Loss(source, _amount);\n    }\n\n    function collectProfits(address source, uint256 _amount) external override minterOnly {\n        _collectProfits(msg.sender, source, _amount);\n    }\n\n    function _collectProfits(address minter, address source, uint256 _amount) internal {\n        _transfer(source, address(reserve), _amount);\n        if (accruedLoss > _amount) {\n            accruedLoss -= _amount;\n            _burn(address(reserve), _amount);\n        } else if (accruedLoss > 0) {\n            _burn(address(reserve), accruedLoss);\n            accruedLoss = 0;\n        }\n        emit Profit(minter, _amount);\n    }\n\n    function synchronizeAccounting() public payable {\n        synchronizeAccounting(\"\");\n    }\n\n    function synchronizeAccounting(Client.EVMExtraArgsV2 calldata extraArgs) public payable {\n        synchronizeAccounting(Client._argsToBytes(extraArgs));\n    }\n\n    /**\n     * Uses a multichain call to send home all accrued profits, if any\n     */\n    function synchronizeAccounting(bytes memory extraArgs) public payable {\n        (uint256 reserveLeft, uint256 _accruedLoss, Client.EVMTokenAmount[] memory tokenAmounts) = getSynchronizeAccountingData();\n\n        if (_accruedLoss > 0) {\n            accruedLoss = 0;\n        }\n        if (reserveLeft > 0) {\n            _transfer(address(reserve), address(this), reserveLeft);\n            _approve(address(this), address(ROUTER), reserveLeft);\n        }\n\n        Client.EVM2AnyMessage memory message = _constructMessage(_toReceiver(BRIDGE_ACCOUNTING), abi.encode(reserveLeft, _accruedLoss), tokenAmounts, extraArgs);\n        _send(MAINNET_CHAIN_SELECTOR, message);\n        emit AccountingSynchronized(reserveLeft, _accruedLoss);\n    }\n\n    /**\n     * @notice Returns the CCIP fee required to synchronize accounting.\n     */\n    function getSynchronizeAccountingFee(bool nativeToken) public view returns (uint256) {\n        return getSynchronizeAccountingFee(nativeToken, \"\");\n    }\n\n    /**\n     * @notice Returns the CCIP fee required to synchronize accounting.\n     */\n    function getSynchronizeAccountingFee(bool nativeToken, bytes memory extraArgs) public view returns (uint256) {\n        (uint256 reserveLeft, uint256 _accruedLoss, Client.EVMTokenAmount[] memory tokenAmounts) = getSynchronizeAccountingData();\n        Client.EVM2AnyMessage memory message = _constructMessage(_toReceiver(BRIDGE_ACCOUNTING), abi.encode(reserveLeft, _accruedLoss), tokenAmounts, nativeToken, extraArgs);\n        return _calculateFee(MAINNET_CHAIN_SELECTOR, message);\n    }\n\n    /**\n     * @notice Returns the data required to synchronize accounting. Including the tokenAmounts array.\n     */\n    function getSynchronizeAccountingData() public view returns (uint256, uint256, Client.EVMTokenAmount[] memory) {\n        uint256 reserveLeft = balanceOf(address(reserve));\n        Client.EVMTokenAmount[] memory tokenAmounts = new Client.EVMTokenAmount[](0);\n        if (reserveLeft > 0) {\n            tokenAmounts = new Client.EVMTokenAmount[](1);\n            tokenAmounts[0] = Client.EVMTokenAmount({token: address(this), amount: reserveLeft});\n        }\n        return (reserveLeft, accruedLoss, tokenAmounts);\n    }\n\n    /**\n     * @notice Returns true if the address is an approved minter.\n     */\n    function isMinter(address _minter) public view returns (bool) {\n        return minters[_minter] != 0 && block.timestamp >= minters[_minter];\n    }\n\n    /**\n     * @notice Returns the address of the minter that created this position or null if the provided address is unknown.\n     */\n    function getPositionParent(address _position) public view returns (address) {\n        return positions[_position];\n    }\n\n    /*\n     * @notice Used to register the token initially in the CCIP environment\n     */\n    function getCCIPAdmin() external view returns (address) {\n        return CCIP_ADMIN;\n    }\n}\n"
    },
    "contracts/stablecoin/Frankencoin.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../erc20/ERC20PermitLight.sol\";\nimport \"../equity/IGovernance.sol\";\nimport \"../equity/Equity.sol\";\nimport \"./IBasicFrankencoin.sol\";\nimport \"./IFrankencoin.sol\";\n\n/**\n * @title FrankenCoin\n * @notice The Frankencoin (ZCHF) is an ERC-20 token that is designed to track the value of the Swiss franc.\n * It is not upgradable, but open to arbitrary minting plugins. These are automatically accepted if none of the\n * qualified pool share holders casts a veto, leading to a flexible but conservative governance.\n */\ncontract Frankencoin is ERC20PermitLight, IFrankencoin {\n    /**\n     * @notice Minimal fee and application period when suggesting a new minter.\n     */\n    uint256 public constant MIN_FEE = 1000 * (10 ** 18);\n    uint256 public immutable MIN_APPLICATION_PERIOD; // for example 10 days\n\n    /**\n     * @notice The contract that holds the reserve.\n     */\n    IGovernance public immutable override reserve;\n\n    /**\n     * @notice How much of the reserve belongs to the minters. Everything else belongs to the pool share holders.\n     * Stored with 6 additional digits of accuracy so no rounding is necessary when dealing with parts per\n     * million (ppm) in reserve calculations.\n     */\n    uint256 private minterReserveE6;\n\n    /**\n     * @notice Map of minters to approval time stamps. If the time stamp is in the past, the minter contract is allowed\n     * to mint Frankencoins.\n     */\n    mapping(address minter => uint256 validityStart) public minters;\n\n    /**\n     * @notice List of positions that are allowed to mint and the minter that registered them.\n     */\n    mapping(address position => address registeringMinter) public positions;\n\n    event MinterApplied(address indexed minter, uint256 applicationPeriod, uint256 applicationFee, string message);\n    event MinterDenied(address indexed minter, string message);\n    event Loss(address indexed reportingMinter, uint256 amount);\n    event Profit(address indexed reportingMinter, uint256 amount);\n\n    error PeriodTooShort();\n    error FeeTooLow();\n    error AlreadyRegistered();\n    error NotMinter();\n    error TooLate();\n\n    modifier minterOnly() {\n        if (!isMinter(msg.sender) && !isMinter(positions[msg.sender])) revert NotMinter();\n        _;\n    }\n\n    /**\n     * @notice Initiates the Frankencoin with the provided minimum application period for new plugins\n     * in seconds, for example 10 days, i.e. 3600*24*10 = 864000\n     */\n    constructor(uint256 _minApplicationPeriod) ERC20(18) {\n        MIN_APPLICATION_PERIOD = _minApplicationPeriod;\n        reserve = new Equity(this);\n    }\n\n    function name() external pure override returns (string memory) {\n        return \"Frankencoin\";\n    }\n\n    function symbol() external pure override returns (string memory) {\n        return \"ZCHF\";\n    }\n\n    function initialize(address _minter, string calldata _message) external {\n        require(totalSupply() == 0 && (Equity(address(reserve)).totalSupply() == 0));\n        minters[_minter] = block.timestamp;\n        emit MinterApplied(_minter, 0, 0, _message);\n    }\n\n    /**\n     * @notice Publicly accessible method to suggest a new way of minting Frankencoin.\n     * @dev The caller has to pay an application fee that is irrevocably lost even if the new minter is vetoed.\n     * The caller must assume that someone will veto the new minter unless there is broad consensus that the new minter\n     * adds value to the Frankencoin system. Complex proposals should have application periods and applications fees\n     * above the minimum. It is assumed that over time, informal ways to coordinate on new minters emerge. The message\n     * parameter might be useful for initiating further communication. Maybe it contains a link to a website describing\n     * the proposed minter.\n     *\n     * @param _minter              An address that is given the permission to mint Frankencoins\n     * @param _applicationPeriod   The time others have to veto the suggestion, at least MIN_APPLICATION_PERIOD\n     * @param _applicationFee      The fee paid by the caller, at least MIN_FEE\n     * @param _message             An optional human readable message to everyone watching this contract\n     */\n    function suggestMinter(\n        address _minter,\n        uint256 _applicationPeriod,\n        uint256 _applicationFee,\n        string calldata _message\n    ) external override {\n        if (_applicationPeriod < MIN_APPLICATION_PERIOD) revert PeriodTooShort();\n        if (_applicationFee < MIN_FEE) revert FeeTooLow();\n        if (minters[_minter] != 0) revert AlreadyRegistered();\n        _collectProfits(address(this), msg.sender, _applicationFee);\n        minters[_minter] = block.timestamp + _applicationPeriod;\n        emit MinterApplied(_minter, _applicationPeriod, _applicationFee, _message);\n    }\n\n    /**\n     * @notice Make the system more user friendly by skipping the allowance in many cases.\n     * @dev We trust minters and the positions they have created to mint and burn as they please, so\n     * giving them arbitrary allowances does not pose an additional risk.\n     */\n    function _allowance(address owner, address spender) internal view override returns (uint256) {\n        uint256 explicit = super._allowance(owner, spender);\n        if (explicit > 0) {\n            return explicit; // don't waste gas checking minter\n        } else if (isMinter(spender) || isMinter(getPositionParent(spender)) || spender == address(reserve)) {\n            return INFINITY;\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n     * @notice The reserve provided by the owners of collateralized positions.\n     * @dev The minter reserve can be used to cover losses after the equity holders have been wiped out.\n     */\n    function minterReserve() public view returns (uint256) {\n        return minterReserveE6 / 1000000;\n    }\n\n    /**\n     * @notice Allows minters to register collateralized debt positions, thereby giving them the ability to mint Frankencoins.\n     * @dev It is assumed that the responsible minter that registers the position ensures that the position can be trusted.\n     */\n    function registerPosition(address _position) external override {\n        if (!isMinter(msg.sender)) revert NotMinter();\n        positions[_position] = msg.sender;\n    }\n\n    /**\n     * @notice The amount of equity of the Frankencoin system in ZCHF, owned by the holders of Frankencoin Pool Shares.\n     * @dev Note that the equity contract technically holds both the minter reserve as well as the equity, so the minter\n     * reserve must be subtracted. All fees and other kind of income is added to the Equity contract and essentially\n     * constitutes profits attributable to the pool share holders.\n     */\n    function equity() public view returns (uint256) {\n        uint256 balance = balanceOf(address(reserve));\n        uint256 minReserve = minterReserve();\n        if (balance <= minReserve) {\n            return 0;\n        } else {\n            return balance - minReserve;\n        }\n    }\n\n    /**\n     * @notice Qualified pool share holders can deny minters during the application period.\n     * @dev Calling this function is relatively cheap thanks to the deletion of a storage slot.\n     */\n    function denyMinter(address _minter, address[] calldata _helpers, string calldata _message) external override {\n        if (block.timestamp > minters[_minter]) revert TooLate();\n        reserve.checkQualified(msg.sender, _helpers);\n        delete minters[_minter];\n        emit MinterDenied(_minter, _message);\n    }\n\n    /**\n     * @notice Mints the provided amount of ZCHF to the target address, automatically forwarding\n     * the minting fee and the reserve to the right place.\n     */\n    function mintWithReserve(\n        address _target,\n        uint256 _amount,\n        uint32 _reservePPM,\n        uint32 _feesPPM\n    ) external override minterOnly {\n        uint256 usableMint = (_amount * (1000_000 - _feesPPM - _reservePPM)) / 1000_000; // rounding down is fine\n        _mint(_target, usableMint);\n        _mint(address(reserve), _amount - usableMint); // rest goes to equity as reserves or as fees\n        minterReserveE6 += _amount * _reservePPM;\n        emit Profit(msg.sender, (_feesPPM * _amount) / 1000_000);\n    }\n\n    function mint(address _target, uint256 _amount) external override minterOnly {\n        _mint(_target, _amount);\n    }\n\n    /**\n     * Anyone is allowed to burn their ZCHF.\n     */\n    function burn(uint256 _amount) external {\n        _burn(msg.sender, _amount);\n    }\n\n    /**\n     * @notice Burn someone elses ZCHF.\n     */\n    function burnFrom(address _owner, uint256 _amount) external override minterOnly {\n        _burn(_owner, _amount);\n    }\n\n    /**\n     * @notice Burn that amount without reclaiming the reserve, but freeing it up and thereby essentially donating it to the\n     * pool share holders. This can make sense in combination with 'coverLoss', i.e. when it is the pool share\n     * holders that bear the risk and depending on the outcome they make a profit or a loss.\n     *\n     * Design rule: Minters calling this method are only allowed to so for tokens amounts they previously minted with\n     * the same _reservePPM amount.\n     *\n     * For example, if someone minted 50 ZCHF earlier with a 20% reserve requirement (200000 ppm), they got 40 ZCHF\n     * and paid 10 ZCHF into the reserve. Now they want to repay the debt by burning 50 ZCHF. When doing so using this\n     * method, 50 ZCHF get burned and on top of that, 10 ZCHF previously assigned to the minter's reserved are\n     * reassigned to the pool share holders.\n     *\n     * CS-ZCHF2-009: the Profit event can overstate profits in case there is no equity capital left.\n     */\n    function burnWithoutReserve(uint256 amount, uint32 reservePPM) public override minterOnly {\n        _burn(msg.sender, amount);\n        uint256 reserveReduction = amount * reservePPM;\n        if (reserveReduction > minterReserveE6) {\n            emit Profit(msg.sender, minterReserveE6 / 1000_000);\n            minterReserveE6 = 0; // should never happen, but we want robust behavior in case it does\n        } else {\n            minterReserveE6 -= reserveReduction;\n            emit Profit(msg.sender, reserveReduction / 1000_000);\n        }\n    }\n\n    /**\n     * @notice Burns the provided number of tokens plus whatever reserves are associated with that amount given the reserve\n     * requirement. The caller is only allowed to use this method for tokens also minted through the caller with the\n     * same _reservePPM amount.\n     *\n     * Example: the calling contract has previously minted 100 ZCHF with a reserve ratio of 20% (i.e. 200000 ppm).\n     * Now they have 41 ZCHF that they do not need so they decide to repay that amount. Assuming the reserves are\n     * only 90% covered, the call to burnWithReserve will burn the 41 plus 9 from the reserve, reducing the outstanding\n     * 'debt' of the caller by 50 ZCHF in total. This total is returned by the method so the caller knows how much less\n     * they owe.\n     */\n    function burnWithReserve(\n        uint256 _amountExcludingReserve,\n        uint32 _reservePPM\n    ) external override minterOnly returns (uint256) {\n        uint256 freedAmount = calculateFreedAmount(_amountExcludingReserve, _reservePPM); // 50 in the example\n        minterReserveE6 -= freedAmount * _reservePPM; // reduce reserve requirements by original ratio\n        _transfer(address(reserve), msg.sender, freedAmount - _amountExcludingReserve); // collect assigned reserve\n        _burn(msg.sender, freedAmount); // burn the rest of the freed amount\n        return freedAmount;\n    }\n\n    /**\n     * @notice Burns the target amount taking the tokens to be burned from the payer and the payer's reserve.\n     * Only use this method for tokens also minted by the caller with the same _reservePPM.\n     *\n     * Example: the calling contract has previously minted 100 ZCHF with a reserve ratio of 20% (i.e. 200000 ppm).\n     * To burn half of that again, the minter calls burnFrom with a target amount of 50 ZCHF. Assuming that reserves\n     * are only 90% covered, this call will deduct 41 ZCHF from the payer's balance and 9 from the reserve, while\n     * reducing the minter reserve by 10.\n     */\n    function burnFromWithReserve(\n        address payer,\n        uint256 targetTotalBurnAmount,\n        uint32 reservePPM\n    ) external override minterOnly returns (uint256) {\n        uint256 assigned = calculateAssignedReserve(targetTotalBurnAmount, reservePPM);\n        _transfer(address(reserve), payer, assigned); // send reserve to owner\n        _burn(payer, targetTotalBurnAmount); // and burn the full amount from the owner's address\n        minterReserveE6 -= targetTotalBurnAmount * reservePPM; // reduce reserve requirements by original ratio\n        return assigned;\n    }\n\n    /**\n     * @notice Calculates the reserve attributable to someone who minted the given amount with the given reserve requirement.\n     * Under normal circumstances, this is just the reserve requirement multiplied by the amount. However, after a\n     * severe loss of capital that burned into the minter's reserve, this can also be less than that.\n     */\n    function calculateAssignedReserve(uint256 mintedAmount, uint32 _reservePPM) public view returns (uint256) {\n        uint256 theoreticalReserve = (_reservePPM * mintedAmount) / 1000000;\n        uint256 currentReserve = balanceOf(address(reserve));\n        uint256 minterReserve_ = minterReserve();\n        if (currentReserve < minterReserve_) {\n            // not enough reserves, owner has to take a loss\n            return (theoreticalReserve * currentReserve) / minterReserve_;\n        } else {\n            return theoreticalReserve;\n        }\n    }\n\n    /**\n     * @notice Calculate the amount that is freed when returning amountExcludingReserve given a reserve ratio of reservePPM,\n     * taking into account potential losses. Example values in the comments.\n     */\n    function calculateFreedAmount(\n        uint256 amountExcludingReserve /* 41 */,\n        uint32 reservePPM /* 20% */\n    ) public view returns (uint256) {\n        uint256 currentReserve = balanceOf(address(reserve)); // 18, 10% below what we should have\n        uint256 minterReserve_ = minterReserve(); // 20\n        uint256 adjustedReservePPM = currentReserve < minterReserve_\n            ? (reservePPM * currentReserve) / minterReserve_\n            : reservePPM; // 18%\n        return (1000000 * amountExcludingReserve) / (1000000 - adjustedReservePPM); // 41 / (1-18%) = 50\n    }\n\n    /**\n     * @notice Notify the Frankencoin that a minter lost economic access to some coins. This does not mean that the coins are\n     * literally lost. It just means that some ZCHF will likely never be repaid and that in order to bring the system\n     * back into balance, the lost amount of ZCHF must be removed from the reserve instead.\n     *\n     * For example, if a minter printed 1 million ZCHF for a mortgage and the mortgage turned out to be unsound with\n     * the house only yielding 800'000 in the subsequent auction, there is a loss of 200'000 that needs to be covered\n     * by the reserve.\n     */\n    function coverLoss(address source, uint256 _amount) external override minterOnly {\n        uint256 reserveLeft = balanceOf(address(reserve));\n        if (reserveLeft >= _amount) {\n            _transfer(address(reserve), source, _amount);\n        } else {\n            _transfer(address(reserve), source, reserveLeft);\n            _mint(source, _amount - reserveLeft);\n        }\n        emit Loss(source, _amount);\n    }\n\n    function collectProfits(address source, uint256 _amount) external override minterOnly {\n        _collectProfits(msg.sender, source, _amount);\n    }\n\n    function _collectProfits(address minter, address source, uint256 _amount) internal {\n        _transfer(source, address(reserve), _amount);\n        emit Profit(minter, _amount);\n    }\n\n    /**\n     * @notice Returns true if the address is an approved minter.\n     */\n    function isMinter(address _minter) public view override returns (bool) {\n        return minters[_minter] != 0 && block.timestamp >= minters[_minter];\n    }\n\n    /**\n     * @notice Returns the address of the minter that created this position or null if the provided address is unknown.\n     */\n    function getPositionParent(address _position) public view override returns (address) {\n        return positions[_position];\n    }\n}\n"
    },
    "contracts/stablecoin/IBasicFrankencoin.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../erc20/IERC20.sol\";\nimport \"../equity/IGovernance.sol\";\n\ninterface IBasicFrankencoin is IERC20 {\n    function MIN_FEE() external view returns (uint256);\n\n    function MIN_APPLICATION_PERIOD() external view returns (uint256);\n\n    function suggestMinter(\n        address _minter,\n        uint256 _applicationPeriod,\n        uint256 _applicationFee,\n        string calldata _message\n    ) external;\n\n    function registerPosition(address position) external;\n\n    function denyMinter(address minter, address[] calldata helpers, string calldata message) external;\n\n    function reserve() external view returns (IGovernance);\n\n    function isMinter(address minter) external view returns (bool);\n\n    function getPositionParent(address position) external view returns (address);\n\n    function mint(address target, uint256 amount) external;\n\n    function burnFrom(address target, uint256 amount) external;\n\n    function burn(uint256 amount) external;\n\n    function coverLoss(address source, uint256 amount) external;\n\n    function collectProfits(address source, uint256 _amount) external;\n}\n"
    },
    "contracts/stablecoin/IFrankencoin.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../equity/IGovernance.sol\";\nimport \"./IBasicFrankencoin.sol\";\n\ninterface IFrankencoin is IBasicFrankencoin {\n\n    function minterReserve() external view returns (uint256);\n\n    function calculateAssignedReserve(uint256 mintedAmount, uint32 _reservePPM) external view returns (uint256);\n\n    function calculateFreedAmount(uint256 amountExcludingReserve, uint32 reservePPM) external view returns (uint256);\n\n    function equity() external view returns (uint256);\n\n    function mintWithReserve(address target, uint256 amount, uint32 reservePPM, uint32 feePPM) external;\n\n    function burnWithoutReserve(uint256 amountIncludingReserve, uint32 reservePPM) external;\n\n    function burnFromWithReserve(address payer, uint256 targetTotalBurnAmount, uint32 _reservePPM) external returns (uint256);\n\n    function burnWithReserve(uint256 amountExcludingReserve, uint32 reservePPM) external returns (uint256);\n\n}\n"
    },
    "contracts/swap/StablecoinBridge.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../erc20/IERC20.sol\";\nimport \"../erc20/IERC677Receiver.sol\";\nimport \"../stablecoin/IFrankencoin.sol\";\n\n/**\n * @title Stable Coin Bridge\n * @notice A minting contract for another Swiss franc stablecoin ('source stablecoin') that we trust.\n * @author Frankencoin\n */\ncontract StablecoinBridge {\n    IERC20 public immutable chf; // the source stablecoin\n    IFrankencoin public immutable zchf; // the Frankencoin\n\n    /**\n     * @notice The time horizon after which this bridge expires and needs to be replaced by a new contract.\n     */\n    uint256 public immutable horizon;\n\n    /**\n     * The maximum amount of outstanding converted source stablecoins.\n     */\n    uint256 public immutable limit;\n    uint256 public minted;\n\n    error Limit(uint256 amount, uint256 limit);\n    error Expired(uint256 time, uint256 expiration);\n    error UnsupportedToken(address token);\n\n    constructor(address other, address zchfAddress, uint256 limit_) {\n        chf = IERC20(other);\n        zchf = IFrankencoin(zchfAddress);\n        horizon = block.timestamp + 52 weeks;\n        limit = limit_;\n        minted = 0;\n    }\n\n    /**\n     * @notice Convenience method for mint(msg.sender, amount)\n     */\n    function mint(uint256 amount) external {\n        mintTo(msg.sender, amount);\n    }\n\n    /**\n     * @notice Mint the target amount of Frankencoins, taking the equal amount of source coins from the sender.\n     * @dev This only works if an allowance for the source coins has been set and the caller has enough of them.\n     */\n    function mintTo(address target, uint256 amount) public {\n        chf.transferFrom(msg.sender, address(this), amount);\n        _mint(target, amount);\n    }\n\n    function _mint(address target, uint256 amount) internal {\n        if (block.timestamp > horizon) revert Expired(block.timestamp, horizon);\n        zchf.mint(target, amount);\n        minted += amount;\n        if (minted > limit) revert Limit(amount, limit);\n    }\n\n    /**\n     * @notice Convenience method for burnAndSend(msg.sender, amount)\n     */\n    function burn(uint256 amount) external {\n        _burn(msg.sender, msg.sender, amount);\n    }\n\n    /**\n     * @notice Burn the indicated amount of Frankencoin and send the same number of source coin to the caller.\n     */\n    function burnAndSend(address target, uint256 amount) external {\n        _burn(msg.sender, target, amount);\n    }\n\n    function _burn(address zchfHolder, address target, uint256 amount) internal {\n        zchf.burnFrom(zchfHolder, amount);\n        chf.transfer(target, amount);\n        minted -= amount;\n    }\n}\n"
    },
    "contracts/test/DeployerFrankencoin.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../stablecoin/Frankencoin.sol\";\nimport \"../minting/PositionFactory.sol\";\nimport \"../minting/MintingHub.sol\";\nimport \"../rate/Leadrate.sol\";\nimport \"../equity/Equity.sol\";\n\ncontract DeployerFrankencoin {\n    string public constant NAME = \"DeployerV0\";\n    Frankencoin public zchf;\n    PositionFactory public factory;\n    Leadrate public leadrate;\n    PositionRoller public roller;\n    MintingHub public mintingHub;\n\n    event Log(address sender, string message);\n\n    constructor() {\n        zchf = new Frankencoin(1);\n        factory = new PositionFactory();\n        roller = new PositionRoller(address(zchf));\n        leadrate = new Leadrate(zchf.reserve(), 20000);\n        mintingHub = new MintingHub(address(zchf), address(leadrate), address(roller), address(factory));\n\n        zchf.initialize(msg.sender, \"Developer\");\n        zchf.initialize(address(this), \"Deployer\");\n        zchf.initialize(address(mintingHub), \"MintingHub\");\n        zchf.initialize(address(roller), \"Roller\");\n    }\n\n    function initA_Frankencoin() public {\n        uint256 toMint = 1_000_000 ether;\n        zchf.mint(address(this), 2 * toMint);\n        Equity(address(zchf.reserve())).invest(toMint, 1000 ether);\n\n        // for sender\n        zchf.mint(msg.sender, toMint);\n    }\n\n    function increaseLeadrate() public {\n        leadrate.proposeChange(leadrate.currentRatePPM() + 1000, new address[](0));\n    }\n\n    function revertLeadrate() public {\n        leadrate.proposeChange(leadrate.currentRatePPM(), new address[](0));\n    }\n}\n"
    },
    "contracts/test/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, \"Math: mulDiv overflow\");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}"
    },
    "contracts/test/MintingHubTest.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./Strings.sol\";\nimport \"./TestToken.sol\";\nimport \"../equity/Equity.sol\";\nimport \"../utils/Ownable.sol\";\nimport \"../minting/Position.sol\";\nimport \"../minting/MintingHub.sol\";\nimport \"../swap/StablecoinBridge.sol\";\nimport \"../minting/IPosition.sol\";\nimport \"../stablecoin/IFrankencoin.sol\";\nimport \"../erc20/IERC20.sol\";\n\ncontract MintingHubTest {\n    MintingHub hub;\n    StablecoinBridge swap;\n\n    IERC20 xchf;\n    TestToken col;\n    IFrankencoin zchf;\n    Equity fps;\n\n    User alice;\n    User bob;\n\n    address latestPosition;\n    uint256 latestChallenge;\n\n    constructor(address hub_, address swap_) {\n        hub = MintingHub(hub_);\n        swap = StablecoinBridge(swap_);\n        col = new TestToken(\"Some Collateral\", \"COL\", uint8(0));\n        xchf = swap.chf();\n        zchf = swap.zchf();\n        alice = new User(zchf);\n        bob = new User(zchf);\n        fps = Equity(address(fps));\n        require(fps.totalSupply() == 0, Strings.toString(fps.totalSupply()));\n    }\n\n    function initiateEquity() public {\n        require(zchf.equity() == 1003849100000000000001, Strings.toString(zchf.equity()));\n        require(fps.totalSupply() == 0, Strings.toString(fps.totalSupply()));\n        // ensure there is at least 25'000 ZCHF in equity\n        bob.obtainFrankencoins(swap, 10000 ether);\n        bob.invest(1000 ether);\n        require(fps.totalSupply() == 1000 ether, Strings.toString(fps.totalSupply()));\n        bob.invest(9000 ether);\n        alice.obtainFrankencoins(swap, 15000 ether);\n        alice.invest(15000 ether);\n        require(zchf.equity() > 25000 ether, Strings.toString(zchf.equity()));\n    }\n\n    function initiateAndDenyPosition() public {\n        alice.obtainFrankencoins(swap, 1000 ether);\n        address pos = alice.initiatePosition(col, hub);\n        bob.deny(hub, pos);\n    }\n\n    function initiatePosition() public {\n        alice.obtainFrankencoins(swap, 1000 ether);\n        latestPosition = alice.initiatePosition(col, hub);\n        require(col.balanceOf(address(alice)) == 0);\n    }\n\n    function testWithdraw() public {\n        alice.testWithdraw(swap, Position(latestPosition));\n    }\n\n    function letAliceMint() public {\n        alice.mint(latestPosition, 1); // test small amount to provoke rounding error\n        alice.transferOwnership(latestPosition, address(bob));\n        uint256 bobbalance = zchf.balanceOf(address(bob));\n        bob.mint(latestPosition, 7);\n        require(zchf.balanceOf(address(bob)) > bobbalance);\n        bob.transferOwnership(latestPosition, address(alice));\n        alice.mint(latestPosition, 0);\n        alice.mint(latestPosition, 100000 * (10 ** 18) - 8);\n        alice.adjustPosition(latestPosition);\n        require(Position(latestPosition).minted() == 100000 ether);\n    }\n\n    function letBobMint() public {\n        bob.mint(latestPosition, 1);\n    }\n\n    uint256 first;\n    uint256 second;\n\n    function letBobChallengePart1() public {\n        col.mint(address(bob), 1300);\n\n        // three challenges in parallel :)\n        first = bob.challenge(hub, latestPosition, 300);\n        second = bob.challenge(hub, latestPosition, 400);\n        latestChallenge = bob.challenge(hub, latestPosition, 500);\n    }\n\n    function letBobChallengePart2() public returns (uint256) {\n        /* alice.avertChallenge(hub, swap, first);\n        bob.obtainFrankencoins(swap, 30_000 ether);\n        bob.bid(hub, second, 10_000 ether);\n        bob.bid(hub, latestChallenge, 20_000 ether);\n        (address challenger, , , , , uint256 bid) = hub.challenges(\n            latestChallenge\n        );\n        require(challenger != address(0x0), \"challenge not found\");\n        require(bid == 20_000 ether);\n        return latestChallenge; */\n    }\n\n    function endChallenges() public {\n        uint256 reservesBefore = zchf.balanceOf(address(fps)) - zchf.equity();\n        // revertWith(\"reserves before \", reservesBefore);  // 21000.000000000000000000\n        endChallenge(latestChallenge); // can be absorbed with equity\n        uint256 reservesAfter = zchf.balanceOf(address(fps)) - zchf.equity();\n        require(reservesBefore - reservesAfter == 10000 ether); // latest challenge was 50'000 with 20% reserve\n        // revertWith(\"reserves before \", reservesAfter);  // 11000.000000000000000000\n        // revertWith(\"reserves before \", zchf.equity());     //  8601.000000000000000003\n        // splitAndEnd(latestChallenge - 1);\n    }\n\n    function endChallenge(uint256 challengeNumber) public {\n        uint256 equityBefore = zchf.equity();\n        (address challenger, uint40 start, IPosition p, uint256 size) = hub.challenges(challengeNumber);\n        require(challenger != address(0x0), \"challenge not found\");\n        // hub.end(challengeNumber, true);\n        User user = challenger == address(bob) ? bob : alice;\n        user.reclaimCollateral(hub, p.collateral(), size);\n\n        /*         uint256 borrowedAmount = 50000 * (10 ** 18);\n        uint256 reserve = (borrowedAmount * p.reserveContribution()) / 1000000;\n        uint256 reward = (bid * 20000) / 1000000;\n        uint256 missing = borrowedAmount + reward - bid - reserve;\n        uint256 equityAfter = zchf.equity();\n        uint256 assigned = zchf.calculateAssignedReserve(\n            1000000,\n            uint32(200000)\n        );\n        if (equityBefore >= missing) {\n            string memory message = string(\n                abi.encodePacked(\n                    Strings.toString(equityBefore),\n                    \" \",\n                    Strings.toString(equityAfter),\n                    \" \",\n                    Strings.toString(missing)\n                )\n            );\n            require(equityAfter + missing == equityBefore, message);\n        } else {\n            // revertWith(\"reserve \", assigned); // 50601000000000000000003\n            require(equityAfter == 0, Strings.toString(equityAfter)); // wiped out equity\n            require(\n                assigned == 0 ||\n                    zchf.calculateAssignedReserve(1000000, 200000) < assigned\n            );\n            // theoretical minter reserve at this point: 3000.000000000000000000, actual: 0\n        } */\n    }\n\n    uint256 number;\n\n    function testExcessiveChallengePart1() public {\n        // revertWith(\"reserve \", zchf.balanceOf(address(fps))); // 50601000000000000000003\n        Position pos = Position(latestPosition);\n        //uint256 minted = pos.minted();\n        //        require(minted == 10000 ether, Strings.toString(minted)); // assumes the other tests have been run before\n        uint256 collateralLeft = pos.collateral().balanceOf(latestPosition);\n        require(collateralLeft == 100, Strings.toString(collateralLeft)); // test assumption\n        number = bob.challenge(hub, latestPosition, 101); // challenge more than is left\n        //   alice.repay(pos, 5000 ether);\n        // require(pos.minted() + 5000 ether == minted);\n        // minted is now 9999.999999999999995000\n    }\n\n    function testExcessiveChallengePart2() public {\n        bob.avertChallenge(hub, swap, number);\n    }\n\n    function restructure() public {\n        address[] memory empty = new address[](0);\n        fps.checkQualified(address(alice), empty);\n        fps.checkQualified(address(bob), empty);\n        address[] memory list = new address[](1);\n        list[0] = address(bob);\n        Equity equity = Equity(address(fps));\n        uint256 totalVotes = equity.totalVotes();\n        uint256 supplyBefore = equity.totalSupply();\n        uint256 bobBefore = equity.balanceOf(address(bob));\n        alice.restructure(empty, list);\n        fps.checkQualified(address(alice), empty);\n        require(equity.totalVotes() < totalVotes);\n        require(equity.balanceOf(address(bob)) == 0);\n        uint256 supplyAfter = equity.totalSupply();\n        require(supplyAfter == supplyBefore - bobBefore);\n        // revertWith(\"Shortfall: \", zchf.minterReserve() - zchf.balanceOf(address(fps))); // 1000000000000000000000\n        alice.obtainFrankencoins(swap, 4000 ether);\n        alice.invest(4000 ether);\n        require(supplyAfter + 1000 ether == equity.totalSupply());\n    }\n\n    // poor man's replacement for console.out in solidity...\n    function revertWith(string memory message, uint256 errorNumber) public pure {\n        revert(string(abi.encodePacked(message, Strings.toString(errorNumber))));\n    }\n\n    function challengeExpiredPosition() public {\n        Position pos = Position(latestPosition);\n        require(pos.calculateCurrentFee() == 0);\n        require(pos.expiration() < block.timestamp);\n        uint256 size = pos.collateral().balanceOf(latestPosition);\n        latestChallenge = bob.challenge(hub, latestPosition, size);\n        // revertWith(\"col left \", size); // 100\n        bob.obtainFrankencoins(swap, 5000 ether);\n    }\n\n    function endLastChallenge() public {\n        Position pos = Position(latestPosition);\n        // hub.end(latestChallenge, false);\n        require(pos.collateral().balanceOf(latestPosition) == 0);\n    }\n}\n\ncontract User {\n    IFrankencoin zchf;\n    Equity fps;\n\n    constructor(IFrankencoin zchf_) {\n        zchf = zchf_;\n        fps = Equity(address(zchf.reserve()));\n    }\n\n    function obtainFrankencoins(StablecoinBridge bridge, uint256 amount) public {\n        TestToken xchf = TestToken(address(bridge.chf()));\n        xchf.mint(address(this), amount);\n        xchf.approve(address(bridge), amount);\n        require(xchf.allowance(address(this), address(bridge)) == amount);\n        bridge.mint(amount);\n    }\n\n    function invest(uint256 amount) public {\n        fps.invest(amount, 0);\n    }\n\n    function transfer(IERC20 token, address target, uint256 amount) public {\n        token.transfer(target, amount);\n    }\n\n    function initiatePosition(TestToken col, MintingHub hub) public returns (address) {\n        col.mint(address(this), 1001);\n        col.approve(address(hub), 1001);\n        uint256 balanceBefore = zchf.balanceOf(address(this));\n        address pos = hub.openPosition(address(col), 100, 1001, 1000000 ether, 7 days, 100 days, 1 days, 25000, 100 * (10 ** 36), 200000);\n        require((balanceBefore - hub.OPENING_FEE()) == zchf.balanceOf(address(this)));\n        Position(pos).adjust(0, 1001, 200 * (10 ** 36));\n        Position(pos).adjustPrice(100 * (10 ** 36));\n        return pos;\n    }\n\n    function transferOwnership(address pos, address newOwner) public {\n        Position(pos).transferOwnership(newOwner);\n    }\n\n    function deny(MintingHub, address pos) public {\n        address[] memory empty = new address[](0);\n        Position(pos).deny(empty, \"not approved\");\n    }\n\n    function adjustPosition(address pos) public {\n        Position position = Position(pos);\n        uint256 minted = position.minted();\n        uint256 col = position.collateral().balanceOf(pos);\n        uint256 price = position.price();\n        position.adjust(minted - 100, col - 1, price);\n        position.collateral().approve(pos, 1);\n        position.adjust(minted, col, price);\n        require(position.minted() == minted);\n        require(position.collateral().balanceOf(pos) == col);\n        require(position.price() == price);\n    }\n\n    function repay(Position pos, uint256 amount) public {\n        uint256 balanceBefore = zchf.balanceOf(address(this));\n        require(balanceBefore >= amount);\n        pos.repay(amount);\n        require(zchf.balanceOf(address(this)) + amount == balanceBefore);\n    }\n\n    function testWithdraw(StablecoinBridge bridge, Position pos) public {\n        IERC20 col = pos.collateral();\n        obtainFrankencoins(bridge, 1);\n        bridge.zchf().transfer(address(pos), 1);\n        uint256 initialBalance = col.balanceOf(address(pos));\n        pos.withdraw(address(bridge.zchf()), address(this), 1);\n        Position(pos).withdraw(address(col), address(this), 1);\n        require(col.balanceOf(address(pos)) == initialBalance - 1);\n        require(col.balanceOf(address(this)) == 1);\n    }\n\n    function mint(address pos, uint256 amount) public {\n        uint256 balanceBefore = zchf.balanceOf(address(this));\n        IPosition(pos).mint(address(this), amount);\n        uint256 obtained = zchf.balanceOf(address(this)) - balanceBefore;\n        uint256 usable = IPosition(pos).getUsableMint(amount, true);\n        require(obtained == usable, string(abi.encodePacked(Strings.toString(usable), \" should be \", Strings.toString(obtained))));\n        uint256 usableBeforeFee = IPosition(pos).getUsableMint(amount, false);\n        require(usable <= 100 || usableBeforeFee > usable, string(abi.encodePacked(Strings.toString(usableBeforeFee), \" should be larger than \", Strings.toString(usable))));\n    }\n\n    function challenge(MintingHub hub, address pos, uint256 size) public returns (uint256) {\n        IERC20 col = IPosition(pos).collateral();\n        col.approve(address(hub), size);\n        return hub.challenge(pos, size, IPosition(pos).price());\n    }\n\n    function avertChallenge(MintingHub hub, StablecoinBridge swap, uint256 first) public {\n        /* {\n            (, IPosition p, uint256 size, , , ) = hub.challenges(first);\n            uint256 amount = (size * p.price()) / 10 ** 18;\n            obtainFrankencoins(swap, amount);\n            hub.bid(first, amount, size); // avert challenge\n        }\n        (address challenger, , , , , ) = hub.challenges(first);\n        require(challenger == address(0x0), \"challenge not averted\");\n        require(!hub.isChallengeOpen(first)); */\n    }\n\n    function bid(MintingHub hub, uint256 number, uint256 amount) public {\n        /*   (, , uint256 size, , , ) = hub.challenges(number);\n        hub.bid(number, amount, size);\n        require(hub.minBid(number) > amount); // min bid must increase */\n    }\n\n    function reclaimCollateral(MintingHub hub, IERC20 collateral, uint256 expectedAmount) public {\n        uint256 balanceBefore = collateral.balanceOf(address(this));\n        hub.returnPostponedCollateral(address(collateral), address(this));\n        uint256 balanceAfter = collateral.balanceOf(address(this));\n        require(balanceBefore + expectedAmount == balanceAfter);\n    }\n\n    function restructure(address[] calldata helpers, address[] calldata addressesToWipe) public {\n        Equity(address(fps)).restructureCapTable(helpers, addressesToWipe);\n    }\n}\n"
    },
    "contracts/test/PositionExpirationTest.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./Strings.sol\";\nimport \"./TestToken.sol\";\nimport \"../equity/Equity.sol\";\nimport \"../utils/Ownable.sol\";\nimport \"../minting/Position.sol\";\nimport \"../minting/MintingHub.sol\";\nimport \"../swap/StablecoinBridge.sol\";\nimport \"../minting/IPosition.sol\";\nimport \"../stablecoin/IFrankencoin.sol\";\nimport \"../erc20/IERC20.sol\";\n\ncontract PositionExpirationTest {\n    MintingHub hub;\n    TestToken col;\n    IFrankencoin zchf;\n\n    constructor(address hub_) {\n        hub = MintingHub(hub_);\n        col = new TestToken(\"Some Collateral\", \"COL\", uint8(0));\n        zchf = hub.zchf();\n    }\n\n    function openPositionFor(address owner) public returns (address) {\n        col.mint(address(this), 100);\n        col.approve(address(hub), 100);\n        address pos = hub.openPosition(address(col), 10, 100 /* collateral */, 1000000 * 10 ** 18, 7 days, 30 days, 10 hours, 50000, 1000 * 10 ** 36 /* price */, 200000);\n        Position(pos).transferOwnership(owner);\n        return pos;\n    }\n\n    function forceBuy(address pos, uint256 amount) public {\n        uint256 price = hub.expiredPurchasePrice(Position(pos));\n        uint256 balanceBefore = zchf.balanceOf(address(this));\n        uint256 colBalBefore = col.balanceOf(address(this));\n        hub.buyExpiredCollateral(Position(pos), amount);\n        uint256 balanceAfter = zchf.balanceOf(address(this));\n        uint256 colBalAfter = col.balanceOf(address(this));\n        require(colBalAfter - colBalBefore == amount, \"collateral amount\");\n        require((balanceBefore - balanceAfter) == (amount * price) / 10 ** 18, \"price paid\");\n    }\n}\n"
    },
    "contracts/test/PositionRollingTest.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./Strings.sol\";\nimport \"./TestToken.sol\";\nimport \"../equity/Equity.sol\";\nimport \"../utils/Ownable.sol\";\nimport \"../minting/Position.sol\";\nimport \"../minting/MintingHub.sol\";\nimport \"../swap/StablecoinBridge.sol\";\nimport \"../minting/IPosition.sol\";\nimport \"../equity/IGovernance.sol\";\nimport \"../stablecoin/IFrankencoin.sol\";\nimport \"../erc20/IERC20.sol\";\n\ncontract PositionRollingTest {\n    MintingHub hub;\n    TestToken col;\n    IFrankencoin zchf;\n    PositionRoller roller;\n\n    IPosition public p1;\n    IPosition public p2;\n\n    constructor(address hub_) {\n        hub = MintingHub(hub_);\n        col = new TestToken(\"Some Collateral\", \"COL\", uint8(0));\n        zchf = hub.zchf();\n        roller = hub.roller();\n    }\n\n    function openTwoPositions() public {\n        p1 = IPosition(openPosition(100, uint40(3 days)));\n        p2 = IPosition(openPosition(10, uint40(7 days)));\n    }\n\n    function mintFromFirstPosition(uint256 amount) public {\n        p1.mint(address(this), amount);\n    }\n\n    function openPosition(uint256 collateral, uint40 initializationDelay) public returns (address) {\n        col.mint(address(this), collateral);\n        col.approve(address(hub), collateral);\n        return hub.openPosition(address(col), 10, collateral, 1000000 * 10 ** 18, initializationDelay, 30 days, 10 hours, 50000, 1000 * 10 ** 36, 200000);\n    }\n\n    function roll() public {\n        col.approve(address(roller), col.balanceOf(address(p1))); // approve full balance\n        roller.rollFully(p1, p2);\n        require(p1.minted() == 0);\n        require(zchf.balanceOf(address(this)) == 0);\n    }\n}\n"
    },
    "contracts/test/SignedMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}"
    },
    "contracts/test/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./Math.sol\";\nimport \"./SignedMath.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}"
    },
    "contracts/test/TestToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../erc20/ERC20.sol\";\n\ncontract TestToken is ERC20 {\n    string public name;\n    string public symbol;\n\n    constructor(\n        string memory name_,\n        string memory symbol_,\n        uint8 dec\n    ) ERC20(dec) {\n        name = name_;\n        symbol = symbol_;\n\n        _mint(msg.sender, 1_000_000 * 1e18);\n    }\n\n    function mint(address _account, uint256 _amount) external {\n        _mint(_account, _amount);\n    }\n}\n"
    },
    "contracts/utils/MathUtil.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title Functions for share valuation\n */\ncontract MathUtil {\n    uint256 internal constant ONE_DEC18 = 10 ** 18;\n\n    // Let's go for 12 digits of precision (18-6)\n    uint256 internal constant THRESH_DEC18 = 10 ** 6;\n\n    /**\n     * @notice Cubic root with Halley approximation\n     *         Number 1e18 decimal\n     * @param _v     number for which we calculate x**(1/3)\n     * @return returns _v**(1/3)\n     */\n    function _cubicRoot(uint256 _v) internal pure returns (uint256) {\n        // Good first guess for _v slightly above 1.0, which is often the case in the Frankencoin system\n        uint256 x = _v > ONE_DEC18 && _v < 10 ** 19 ? (_v - ONE_DEC18) / 3 + ONE_DEC18 : ONE_DEC18;\n        uint256 diff;\n        do {\n            uint256 powX3 = _mulD18(_mulD18(x, x), x);\n            uint256 xnew = x * (powX3 + 2 * _v) / (2 * powX3 + _v);\n            diff = xnew > x ? xnew - x : x - xnew;\n            x = xnew;\n        } while (diff > THRESH_DEC18);\n        return x;\n    }\n\n    function _mulD18(uint256 _a, uint256 _b) internal pure returns (uint256) {\n        return (_a * _b) / ONE_DEC18;\n    }\n\n    function _divD18(uint256 _a, uint256 _b) internal pure returns (uint256) {\n        return (_a * ONE_DEC18) / _b;\n    }\n\n    function _power3(uint256 _x) internal pure returns (uint256) {\n        return _mulD18(_mulD18(_x, _x), _x);\n    }\n\n    function _min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n}\n"
    },
    "contracts/utils/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n//\n// From https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol\n//\n// Modifications:\n// - Replaced Context._msgSender() with msg.sender\n// - Made leaner\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n */\ncontract Ownable {\n\n    address public owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    error NotOwner();\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _setOwner(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _setOwner(address newOwner) internal {\n        require(newOwner != address(0x0));\n        address oldOwner = owner;\n        owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    function _requireOwner(address sender) internal view {\n        if (owner != sender) revert NotOwner();\n    }\n\n    modifier onlyOwner() {\n        _requireOwner(msg.sender);\n        _;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}